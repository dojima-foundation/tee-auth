name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  GO_VERSION: '1.23'
  POSTGRES_VERSION: '15'
  REDIS_VERSION: '7'

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: |
        go mod download
        go mod tidy

    - name: Install coverage tools
      run: |
        go install github.com/axw/gocov/gocov@latest
        go install github.com/AlekSi/gocov-xml@latest
        go install github.com/matm/gocov-html@latest

    - name: Run unit tests
      run: |
        mkdir -p coverage
        go test -v -race -covermode=atomic -coverprofile=coverage/unit.out ./internal/... ./pkg/...

    - name: Generate coverage reports
      run: |
        go tool cover -html=coverage/unit.out -o coverage/unit.html
        gocov convert coverage/unit.out | gocov-xml > coverage/unit.xml

    - name: Check coverage threshold
      run: |
        COVERAGE=$(go tool cover -func=coverage/unit.out | grep total | grep -oE '[0-9]+\.[0-9]+')
        echo "Unit test coverage: ${COVERAGE}%"
        if (( $(echo "$COVERAGE < 70.0" | bc -l) )); then
          echo "Unit test coverage below 70%"
          exit 1
        fi

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/unit.xml
        flags: unit
        name: unit-tests

    - name: Upload unit test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: unit-test-results
        path: coverage/

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:${{ env.POSTGRES_VERSION }}
        env:
          POSTGRES_USER: gauth
          POSTGRES_PASSWORD: password
          POSTGRES_DB: gauth_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:${{ env.REDIS_VERSION }}
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: |
        go mod download
        go mod tidy

    - name: Wait for services
      run: |
        timeout 30 bash -c 'until pg_isready -h localhost -p 5432 -U gauth; do sleep 1; done'
        timeout 30 bash -c 'until redis-cli -h localhost -p 6379 ping; do sleep 1; done'

    - name: Run database migrations
      run: |
        # Install migrate tool
        go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
        # Run migrations
        migrate -path migrations -database "postgres://gauth:password@localhost:5432/gauth_test?sslmode=disable" up

    - name: Run integration tests
      env:
        INTEGRATION_TESTS: true
        TEST_DB_HOST: localhost
        TEST_DB_PORT: 5432
        TEST_DB_USER: gauth
        TEST_DB_PASSWORD: password
        TEST_DB_NAME: gauth_test
        TEST_REDIS_HOST: localhost
        TEST_REDIS_PORT: 6379
      run: |
        mkdir -p coverage
        go test -v -race -timeout=5m -covermode=atomic -coverprofile=coverage/integration.out ./test/integration/...

    - name: Generate integration coverage
      run: |
        go tool cover -html=coverage/integration.out -o coverage/integration.html

    - name: Upload integration test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: integration-test-results
        path: coverage/

  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:${{ env.POSTGRES_VERSION }}
        env:
          POSTGRES_USER: gauth
          POSTGRES_PASSWORD: password
          POSTGRES_DB: gauth_e2e
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:${{ env.REDIS_VERSION }}
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build gauth binary
      run: |
        make build-local

    - name: Setup renclave-v2 (mock)
      run: |
        # Create a simple mock renclave-v2 service for E2E tests
        cat > mock-renclave.go << 'EOF'
        package main
        
        import (
          "encoding/json"
          "net/http"
          "log"
        )
        
        type SeedResponse struct {
          SeedPhrase string `json:"seed_phrase"`
          Entropy    string `json:"entropy"`
          Strength   int    `json:"strength"`
          WordCount  int    `json:"word_count"`
        }
        
        type ValidateResponse struct {
          IsValid   bool     `json:"is_valid"`
          Strength  int      `json:"strength"`
          WordCount int      `json:"word_count"`
          Errors    []string `json:"errors"`
        }
        
        type InfoResponse struct {
          Version      string   `json:"version"`
          EnclaveID    string   `json:"enclave_id"`
          Capabilities []string `json:"capabilities"`
          Healthy      bool     `json:"healthy"`
        }
        
        func main() {
          http.HandleFunc("/generate-seed", func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(SeedResponse{
              SeedPhrase: "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
              Entropy:    "00000000000000000000000000000000",
              Strength:   256,
              WordCount:  24,
            })
          })
          
          http.HandleFunc("/validate-seed", func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(ValidateResponse{
              IsValid:   true,
              Strength:  256,
              WordCount: 24,
              Errors:    []string{},
            })
          })
          
          http.HandleFunc("/info", func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(InfoResponse{
              Version:      "1.0.0-mock",
              EnclaveID:    "mock-enclave-id",
              Capabilities: []string{"seed_generation", "bip39_compliance"},
              Healthy:      true,
            })
          })
          
          http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
          })
          
          log.Println("Mock renclave-v2 server starting on :3000")
          log.Fatal(http.ListenAndServe(":3000", nil))
        }
        EOF
        
        go build -o mock-renclave mock-renclave.go
        ./mock-renclave &
        sleep 2

    - name: Run database migrations
      run: |
        go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
        migrate -path migrations -database "postgres://gauth:password@localhost:5432/gauth_e2e?sslmode=disable" up

    - name: Start gauth service
      env:
        GRPC_PORT: 9090
        DB_HOST: localhost
        DB_PORT: 5432
        DB_USERNAME: gauth
        DB_PASSWORD: password
        DB_DATABASE: gauth_e2e
        REDIS_HOST: localhost
        REDIS_PORT: 6379
        REDIS_DATABASE: 4
        RENCLAVE_HOST: localhost
        RENCLAVE_PORT: 3000
        JWT_SECRET: e2e-test-secret-key-32-bytes-long
        ENCRYPTION_KEY: e2e-test-encryption-key-32-bytes
        LOG_LEVEL: info
      run: |
        ./bin/gauth &
        sleep 5

    - name: Run E2E tests
      env:
        E2E_TESTS: true
        E2E_GAUTH_HOST: localhost
        E2E_GAUTH_PORT: 9090
        E2E_RENCLAVE_HOST: localhost
        E2E_RENCLAVE_PORT: 3000
      run: |
        go test -v -timeout=10m ./test/e2e/...

    - name: Upload E2E test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: e2e-test-results
        path: coverage/

  coverage-report:
    name: Coverage Report
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Download unit test results
      uses: actions/download-artifact@v3
      with:
        name: unit-test-results
        path: coverage/unit/

    - name: Download integration test results
      uses: actions/download-artifact@v3
      with:
        name: integration-test-results
        path: coverage/integration/

    - name: Install coverage tools
      run: |
        go install github.com/axw/gocov/gocov@latest
        go install github.com/AlekSi/gocov-xml@latest

    - name: Merge coverage reports
      run: |
        mkdir -p coverage
        echo "mode: atomic" > coverage/merged.out
        if [ -f coverage/unit/unit.out ]; then
          tail -n +2 coverage/unit/unit.out >> coverage/merged.out
        fi
        if [ -f coverage/integration/integration.out ]; then
          tail -n +2 coverage/integration/integration.out >> coverage/merged.out
        fi

    - name: Generate final coverage report
      run: |
        go tool cover -html=coverage/merged.out -o coverage/coverage.html
        gocov convert coverage/merged.out | gocov-xml > coverage/coverage.xml
        COVERAGE=$(go tool cover -func=coverage/merged.out | grep total | grep -oE '[0-9]+\.[0-9]+')
        echo "TOTAL_COVERAGE=${COVERAGE}" >> $GITHUB_ENV
        echo "Total coverage: ${COVERAGE}%"

    - name: Check total coverage threshold
      run: |
        if (( $(echo "$TOTAL_COVERAGE < 80.0" | bc -l) )); then
          echo "Total coverage ${TOTAL_COVERAGE}% is below 80%"
          exit 1
        fi
        echo "Coverage ${TOTAL_COVERAGE}% meets requirements ✓"

    - name: Upload final coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/coverage.xml
        flags: total
        name: total-coverage

    - name: Upload coverage artifacts
      uses: actions/upload-artifact@v3
      with:
        name: final-coverage-report
        path: coverage/

    - name: Comment coverage on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const coverage = process.env.TOTAL_COVERAGE;
          const body = `## 📊 Test Coverage Report
          
          **Total Coverage:** ${coverage}%
          
          ${coverage >= 80 ? '✅' : '❌'} Coverage ${coverage >= 80 ? 'meets' : 'below'} 80% requirement
          
          ### Coverage by Test Type:
          - Unit Tests: Available in artifacts
          - Integration Tests: Available in artifacts
          - E2E Tests: Functional validation
          
          📋 [View detailed report in artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    services:
      postgres:
        image: postgres:${{ env.POSTGRES_VERSION }}
        env:
          POSTGRES_USER: gauth
          POSTGRES_PASSWORD: password
          POSTGRES_DB: gauth_perf
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:${{ env.REDIS_VERSION }}
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install dependencies
      run: go mod download

    - name: Run benchmarks
      env:
        INTEGRATION_TESTS: true
        TEST_DB_HOST: localhost
        TEST_DB_PORT: 5432
        TEST_DB_USER: gauth
        TEST_DB_PASSWORD: password
        TEST_DB_NAME: gauth_perf
        TEST_REDIS_HOST: localhost
        TEST_REDIS_PORT: 6379
      run: |
        go test -bench=. -benchmem -run=^$ ./... > benchmarks.txt 2>&1 || true
        cat benchmarks.txt

    - name: Upload benchmark results
      uses: actions/upload-artifact@v3
      with:
        name: benchmark-results
        path: benchmarks.txt
