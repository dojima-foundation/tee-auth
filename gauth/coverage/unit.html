
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dojima-foundation/tee-auth/gauth/internal/db/postgres.go (0.0%)</option>
				
				<option value="file1">github.com/dojima-foundation/tee-auth/gauth/internal/db/redis.go (0.0%)</option>
				
				<option value="file2">github.com/dojima-foundation/tee-auth/gauth/internal/grpc/converters.go (0.0%)</option>
				
				<option value="file3">github.com/dojima-foundation/tee-auth/gauth/internal/grpc/server.go (0.0%)</option>
				
				<option value="file4">github.com/dojima-foundation/tee-auth/gauth/internal/models/organization.go (100.0%)</option>
				
				<option value="file5">github.com/dojima-foundation/tee-auth/gauth/internal/service/renclave_client.go (95.8%)</option>
				
				<option value="file6">github.com/dojima-foundation/tee-auth/gauth/internal/service/service.go (6.8%)</option>
				
				<option value="file7">github.com/dojima-foundation/tee-auth/gauth/pkg/config/config.go (0.0%)</option>
				
				<option value="file8">github.com/dojima-foundation/tee-auth/gauth/pkg/logger/logger.go (6.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "context"
        "fmt"
        "time"

        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// PostgresDB represents a PostgreSQL database connection
type PostgresDB struct {
        db     *gorm.DB
        config *config.DatabaseConfig
}

// NewPostgresDB creates a new PostgreSQL database connection
func NewPostgresDB(cfg *config.DatabaseConfig) (*PostgresDB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host, cfg.Port, cfg.Username, cfg.Password, cfg.Database, cfg.SSLMode)

        // Configure GORM logger based on environment
        var gormLogger logger.Interface
        if cfg.Database == "development" </span><span class="cov0" title="0">{
                gormLogger = logger.Default.LogMode(logger.Info)
        }</span> else<span class="cov0" title="0"> {
                gormLogger = logger.Default.LogMode(logger.Silent)
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: gormLogger,
                NowFunc: func() time.Time </span><span class="cov0" title="0">{
                        return time.Now().UTC()
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to PostgreSQL: %w", err)
        }</span>

        // Get underlying sql.DB to configure connection pool
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
        sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(cfg.MaxLifetime)

        // Test the connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping PostgreSQL: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PostgresDB{
                db:     db,
                config: cfg,
        }, nil</span>
}

// GetDB returns the GORM database instance
func (p *PostgresDB) GetDB() *gorm.DB <span class="cov0" title="0">{
        return p.db
}</span>

// Close closes the database connection
func (p *PostgresDB) Close() error <span class="cov0" title="0">{
        sqlDB, err := p.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        <span class="cov0" title="0">return sqlDB.Close()</span>
}

// Health checks the database connection health
func (p *PostgresDB) Health(ctx context.Context) error <span class="cov0" title="0">{
        sqlDB, err := p.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>
        <span class="cov0" title="0">return sqlDB.PingContext(ctx)</span>
}

// GetStats returns database connection statistics
func (p *PostgresDB) GetStats() map[string]interface{} <span class="cov0" title="0">{
        sqlDB, err := p.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "error": err.Error(),
                }
        }</span>

        <span class="cov0" title="0">stats := sqlDB.Stats()
        return map[string]interface{}{
                "max_open_connections": stats.MaxOpenConnections,
                "open_connections":     stats.OpenConnections,
                "in_use":               stats.InUse,
                "idle":                 stats.Idle,
                "wait_count":           stats.WaitCount,
                "wait_duration":        stats.WaitDuration.String(),
                "max_idle_closed":      stats.MaxIdleClosed,
                "max_idle_time_closed": stats.MaxIdleTimeClosed,
                "max_lifetime_closed":  stats.MaxLifetimeClosed,
        }</span>
}

// Transaction executes a function within a database transaction
func (p *PostgresDB) Transaction(fn func(*gorm.DB) error) error <span class="cov0" title="0">{
        return p.db.Transaction(fn)
}</span>

// BeginTx starts a new transaction with context
func (p *PostgresDB) BeginTx(ctx context.Context) *gorm.DB <span class="cov0" title="0">{
        return p.db.WithContext(ctx).Begin()
}</span>

// Migrate runs database migrations
func (p *PostgresDB) Migrate() error <span class="cov0" title="0">{
        // Auto-migrate would be handled by migration files
        // This is a placeholder for any additional migration logic
        return nil
}</span>

// DatabaseInterface defines the interface for database operations
type DatabaseInterface interface {
        GetDB() *gorm.DB
        Close() error
        Health(ctx context.Context) error
        GetStats() map[string]interface{}
        Transaction(fn func(*gorm.DB) error) error
        BeginTx(ctx context.Context) *gorm.DB
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import (
        "context"
        "fmt"
        "time"

        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
        "github.com/redis/go-redis/v9"
)

// RedisClient represents a Redis client connection
type RedisClient struct {
        client *redis.Client
        config *config.RedisConfig
}

// NewRedisClient creates a new Redis client connection
func NewRedisClient(cfg *config.RedisConfig) (*RedisClient, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:         fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
                Password:     cfg.Password,
                DB:           cfg.Database,
                PoolSize:     cfg.PoolSize,
                MinIdleConns: cfg.MinIdleConns,
                DialTimeout:  cfg.DialTimeout,
                ReadTimeout:  cfg.ReadTimeout,
                WriteTimeout: cfg.WriteTimeout,
        })

        // Test the connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisClient{
                client: client,
                config: cfg,
        }, nil</span>
}

// GetClient returns the Redis client instance
func (r *RedisClient) GetClient() *redis.Client <span class="cov0" title="0">{
        return r.client
}</span>

// Close closes the Redis connection
func (r *RedisClient) Close() error <span class="cov0" title="0">{
        return r.client.Close()
}</span>

// Health checks the Redis connection health
func (r *RedisClient) Health(ctx context.Context) error <span class="cov0" title="0">{
        return r.client.Ping(ctx).Err()
}</span>

// GetStats returns Redis connection statistics
func (r *RedisClient) GetStats() map[string]interface{} <span class="cov0" title="0">{
        stats := r.client.PoolStats()
        return map[string]interface{}{
                "hits":        stats.Hits,
                "misses":      stats.Misses,
                "timeouts":    stats.Timeouts,
                "total_conns": stats.TotalConns,
                "idle_conns":  stats.IdleConns,
                "stale_conns": stats.StaleConns,
        }
}</span>

// Session management methods

// SetSession stores a session in Redis with expiration
func (r *RedisClient) SetSession(ctx context.Context, sessionID string, data interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        return r.client.Set(ctx, fmt.Sprintf("session:%s", sessionID), data, expiration).Err()
}</span>

// GetSession retrieves a session from Redis
func (r *RedisClient) GetSession(ctx context.Context, sessionID string) (string, error) <span class="cov0" title="0">{
        return r.client.Get(ctx, fmt.Sprintf("session:%s", sessionID)).Result()
}</span>

// DeleteSession removes a session from Redis
func (r *RedisClient) DeleteSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        return r.client.Del(ctx, fmt.Sprintf("session:%s", sessionID)).Err()
}</span>

// ExtendSession extends the expiration of a session
func (r *RedisClient) ExtendSession(ctx context.Context, sessionID string, expiration time.Duration) error <span class="cov0" title="0">{
        return r.client.Expire(ctx, fmt.Sprintf("session:%s", sessionID), expiration).Err()
}</span>

// Cache management methods

// Set stores a key-value pair in Redis with expiration
func (r *RedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        return r.client.Set(ctx, key, value, expiration).Err()
}</span>

// Get retrieves a value from Redis
func (r *RedisClient) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.client.Get(ctx, key).Result()
}</span>

// Delete removes a key from Redis
func (r *RedisClient) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        return r.client.Del(ctx, key).Err()
}</span>

// Exists checks if a key exists in Redis
func (r *RedisClient) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        result, err := r.client.Exists(ctx, key).Result()
        return result &gt; 0, err
}</span>

// SetNX sets a key only if it doesn't exist (atomic operation)
func (r *RedisClient) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        return r.client.SetNX(ctx, key, value, expiration).Result()
}</span>

// Rate limiting methods

// IncrementCounter increments a counter with expiration (for rate limiting)
func (r *RedisClient) IncrementCounter(ctx context.Context, key string, expiration time.Duration) (int64, error) <span class="cov0" title="0">{
        pipe := r.client.TxPipeline()
        incr := pipe.Incr(ctx, key)
        pipe.Expire(ctx, key, expiration)
        _, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return incr.Val(), nil</span>
}

// GetCounter gets the current value of a counter
func (r *RedisClient) GetCounter(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        result, err := r.client.Get(ctx, key).Int64()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return result, err</span>
}

// Lock management methods (for distributed locking)

// AcquireLock attempts to acquire a distributed lock
func (r *RedisClient) AcquireLock(ctx context.Context, lockKey string, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        return r.client.SetNX(ctx, fmt.Sprintf("lock:%s", lockKey), "locked", expiration).Result()
}</span>

// ReleaseLock releases a distributed lock
func (r *RedisClient) ReleaseLock(ctx context.Context, lockKey string) error <span class="cov0" title="0">{
        return r.client.Del(ctx, fmt.Sprintf("lock:%s", lockKey)).Err()
}</span>

// ExtendLock extends the expiration of a lock
func (r *RedisClient) ExtendLock(ctx context.Context, lockKey string, expiration time.Duration) error <span class="cov0" title="0">{
        return r.client.Expire(ctx, fmt.Sprintf("lock:%s", lockKey), expiration).Err()
}</span>

// List operations for queues and notifications

// LPush pushes elements to the left of a list
func (r *RedisClient) LPush(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        return r.client.LPush(ctx, key, values...).Err()
}</span>

// RPop pops an element from the right of a list
func (r *RedisClient) RPop(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.client.RPop(ctx, key).Result()
}</span>

// BRPop blocks and pops an element from the right of a list with timeout
func (r *RedisClient) BRPop(ctx context.Context, timeout time.Duration, keys ...string) ([]string, error) <span class="cov0" title="0">{
        return r.client.BRPop(ctx, timeout, keys...).Result()
}</span>

// LLen returns the length of a list
func (r *RedisClient) LLen(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return r.client.LLen(ctx, key).Result()
}</span>

// Hash operations for complex data structures

// HSet sets field-value pairs in a hash
func (r *RedisClient) HSet(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        return r.client.HSet(ctx, key, values...).Err()
}</span>

// HGet gets a field value from a hash
func (r *RedisClient) HGet(ctx context.Context, key, field string) (string, error) <span class="cov0" title="0">{
        return r.client.HGet(ctx, key, field).Result()
}</span>

// HGetAll gets all field-value pairs from a hash
func (r *RedisClient) HGetAll(ctx context.Context, key string) (map[string]string, error) <span class="cov0" title="0">{
        return r.client.HGetAll(ctx, key).Result()
}</span>

// HDel deletes fields from a hash
func (r *RedisClient) HDel(ctx context.Context, key string, fields ...string) error <span class="cov0" title="0">{
        return r.client.HDel(ctx, key, fields...).Err()
}</span>

// Pub/Sub operations for real-time notifications

// Publish publishes a message to a channel
func (r *RedisClient) Publish(ctx context.Context, channel string, message interface{}) error <span class="cov0" title="0">{
        return r.client.Publish(ctx, channel, message).Err()
}</span>

// Subscribe subscribes to channels
func (r *RedisClient) Subscribe(ctx context.Context, channels ...string) *redis.PubSub <span class="cov0" title="0">{
        return r.client.Subscribe(ctx, channels...)
}</span>

// PSubscribe subscribes to channels matching patterns
func (r *RedisClient) PSubscribe(ctx context.Context, patterns ...string) *redis.PubSub <span class="cov0" title="0">{
        return r.client.PSubscribe(ctx, patterns...)
}</span>

// RedisInterface defines the interface for Redis operations
type RedisInterface interface {
        GetClient() *redis.Client
        Close() error
        Health(ctx context.Context) error
        GetStats() map[string]interface{}

        // Session management
        SetSession(ctx context.Context, sessionID string, data interface{}, expiration time.Duration) error
        GetSession(ctx context.Context, sessionID string) (string, error)
        DeleteSession(ctx context.Context, sessionID string) error
        ExtendSession(ctx context.Context, sessionID string, expiration time.Duration) error

        // Basic operations
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
        Get(ctx context.Context, key string) (string, error)
        Delete(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)
        SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) (bool, error)

        // Rate limiting
        IncrementCounter(ctx context.Context, key string, expiration time.Duration) (int64, error)
        GetCounter(ctx context.Context, key string) (int64, error)

        // Distributed locking
        AcquireLock(ctx context.Context, lockKey string, expiration time.Duration) (bool, error)
        ReleaseLock(ctx context.Context, lockKey string) error
        ExtendLock(ctx context.Context, lockKey string, expiration time.Duration) error
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package grpc

import (
        pb "github.com/dojima-foundation/tee-auth/gauth/api/proto"
        "github.com/dojima-foundation/tee-auth/gauth/internal/models"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// convertOrganizationToProto converts a models.Organization to pb.Organization
func convertOrganizationToProto(org *models.Organization) *pb.Organization <span class="cov0" title="0">{
        if org == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert users
        <span class="cov0" title="0">users := make([]*pb.User, len(org.Users))
        for i, user := range org.Users </span><span class="cov0" title="0">{
                users[i] = convertUserToProto(&amp;user)
        }</span>

        // Convert invitations
        <span class="cov0" title="0">invitations := make([]*pb.Invitation, len(org.Invitations))
        for i, inv := range org.Invitations </span><span class="cov0" title="0">{
                invitations[i] = convertInvitationToProto(&amp;inv)
        }</span>

        // Convert policies
        <span class="cov0" title="0">policies := make([]*pb.Policy, len(org.Policies))
        for i, policy := range org.Policies </span><span class="cov0" title="0">{
                policies[i] = convertPolicyToProto(&amp;policy)
        }</span>

        // Convert tags
        <span class="cov0" title="0">tags := make([]*pb.Tag, len(org.Tags))
        for i, tag := range org.Tags </span><span class="cov0" title="0">{
                tags[i] = convertTagToProto(&amp;tag)
        }</span>

        // Convert private keys
        <span class="cov0" title="0">privateKeys := make([]*pb.PrivateKey, len(org.PrivateKeys))
        for i, pk := range org.PrivateKeys </span><span class="cov0" title="0">{
                privateKeys[i] = convertPrivateKeyToProto(&amp;pk)
        }</span>

        // Convert wallets
        <span class="cov0" title="0">wallets := make([]*pb.Wallet, len(org.Wallets))
        for i, wallet := range org.Wallets </span><span class="cov0" title="0">{
                wallets[i] = convertWalletToProto(&amp;wallet)
        }</span>

        <span class="cov0" title="0">return &amp;pb.Organization{
                Id:          org.ID.String(),
                Version:     org.Version,
                Name:        org.Name,
                Users:       users,
                RootQuorum:  convertQuorumToProto(&amp;org.RootQuorum),
                Invitations: invitations,
                Policies:    policies,
                Tags:        tags,
                PrivateKeys: privateKeys,
                Wallets:     wallets,
                CreatedAt:   timestamppb.New(org.CreatedAt),
                UpdatedAt:   timestamppb.New(org.UpdatedAt),
        }</span>
}

// convertUserToProto converts a models.User to pb.User
func convertUserToProto(user *models.User) *pb.User <span class="cov0" title="0">{
        if user == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert auth methods
        <span class="cov0" title="0">authMethods := make([]*pb.AuthMethod, len(user.AuthMethods))
        for i, am := range user.AuthMethods </span><span class="cov0" title="0">{
                authMethods[i] = convertAuthMethodToProto(&amp;am)
        }</span>

        <span class="cov0" title="0">return &amp;pb.User{
                Id:             user.ID.String(),
                OrganizationId: user.OrganizationID.String(),
                Username:       user.Username,
                Email:          user.Email,
                PublicKey:      user.PublicKey,
                AuthMethods:    authMethods,
                Tags:           user.Tags,
                IsActive:       user.IsActive,
                CreatedAt:      timestamppb.New(user.CreatedAt),
                UpdatedAt:      timestamppb.New(user.UpdatedAt),
        }</span>
}

// convertAuthMethodToProto converts a models.AuthMethod to pb.AuthMethod
func convertAuthMethodToProto(am *models.AuthMethod) *pb.AuthMethod <span class="cov0" title="0">{
        if am == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.AuthMethod{
                Id:        am.ID.String(),
                UserId:    am.UserID.String(),
                Type:      am.Type,
                Name:      am.Name,
                Data:      am.Data,
                IsActive:  am.IsActive,
                CreatedAt: timestamppb.New(am.CreatedAt),
                UpdatedAt: timestamppb.New(am.UpdatedAt),
        }</span>
}

// convertQuorumToProto converts a models.Quorum to pb.Quorum
func convertQuorumToProto(quorum *models.Quorum) *pb.Quorum <span class="cov0" title="0">{
        if quorum == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userIds := make([]string, len(quorum.UserIDs))
        for i, id := range quorum.UserIDs </span><span class="cov0" title="0">{
                userIds[i] = id.String()
        }</span>

        <span class="cov0" title="0">return &amp;pb.Quorum{
                UserIds:   userIds,
                Threshold: int32(quorum.Threshold),
        }</span>
}

// convertInvitationToProto converts a models.Invitation to pb.Invitation
func convertInvitationToProto(inv *models.Invitation) *pb.Invitation <span class="cov0" title="0">{
        if inv == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">invitation := &amp;pb.Invitation{
                Id:             inv.ID.String(),
                OrganizationId: inv.OrganizationID.String(),
                Email:          inv.Email,
                Role:           inv.Role,
                Token:          inv.Token,
                ExpiresAt:      timestamppb.New(inv.ExpiresAt),
                CreatedAt:      timestamppb.New(inv.CreatedAt),
        }

        if inv.AcceptedAt != nil </span><span class="cov0" title="0">{
                invitation.AcceptedAt = timestamppb.New(*inv.AcceptedAt)
        }</span>

        <span class="cov0" title="0">return invitation</span>
}

// convertPolicyToProto converts a models.Policy to pb.Policy
func convertPolicyToProto(policy *models.Policy) *pb.Policy <span class="cov0" title="0">{
        if policy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.Policy{
                Id:             policy.ID.String(),
                OrganizationId: policy.OrganizationID.String(),
                Name:           policy.Name,
                Description:    policy.Description,
                Rules:          policy.Rules,
                IsActive:       policy.IsActive,
                CreatedAt:      timestamppb.New(policy.CreatedAt),
                UpdatedAt:      timestamppb.New(policy.UpdatedAt),
        }</span>
}

// convertTagToProto converts a models.Tag to pb.Tag
func convertTagToProto(tag *models.Tag) *pb.Tag <span class="cov0" title="0">{
        if tag == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.Tag{
                Id:             tag.ID.String(),
                OrganizationId: tag.OrganizationID.String(),
                Name:           tag.Name,
                Description:    tag.Description,
                Color:          tag.Color,
                CreatedAt:      timestamppb.New(tag.CreatedAt),
        }</span>
}

// convertPrivateKeyToProto converts a models.PrivateKey to pb.PrivateKey
func convertPrivateKeyToProto(pk *models.PrivateKey) *pb.PrivateKey <span class="cov0" title="0">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.PrivateKey{
                Id:             pk.ID.String(),
                OrganizationId: pk.OrganizationID.String(),
                Name:           pk.Name,
                PublicKey:      pk.PublicKey,
                Curve:          pk.Curve,
                Tags:           pk.Tags,
                IsActive:       pk.IsActive,
                CreatedAt:      timestamppb.New(pk.CreatedAt),
                UpdatedAt:      timestamppb.New(pk.UpdatedAt),
        }</span>
}

// convertWalletToProto converts a models.Wallet to pb.Wallet
func convertWalletToProto(wallet *models.Wallet) *pb.Wallet <span class="cov0" title="0">{
        if wallet == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert wallet accounts
        <span class="cov0" title="0">accounts := make([]*pb.WalletAccount, len(wallet.Accounts))
        for i, account := range wallet.Accounts </span><span class="cov0" title="0">{
                accounts[i] = convertWalletAccountToProto(&amp;account)
        }</span>

        <span class="cov0" title="0">return &amp;pb.Wallet{
                Id:             wallet.ID.String(),
                OrganizationId: wallet.OrganizationID.String(),
                Name:           wallet.Name,
                PublicKey:      wallet.PublicKey,
                Accounts:       accounts,
                Tags:           wallet.Tags,
                IsActive:       wallet.IsActive,
                CreatedAt:      timestamppb.New(wallet.CreatedAt),
                UpdatedAt:      timestamppb.New(wallet.UpdatedAt),
        }</span>
}

// convertWalletAccountToProto converts a models.WalletAccount to pb.WalletAccount
func convertWalletAccountToProto(account *models.WalletAccount) *pb.WalletAccount <span class="cov0" title="0">{
        if account == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.WalletAccount{
                Id:            account.ID.String(),
                WalletId:      account.WalletID.String(),
                Name:          account.Name,
                Path:          account.Path,
                PublicKey:     account.PublicKey,
                Address:       account.Address,
                Curve:         account.Curve,
                AddressFormat: account.AddressFormat,
                IsActive:      account.IsActive,
                CreatedAt:     timestamppb.New(account.CreatedAt),
                UpdatedAt:     timestamppb.New(account.UpdatedAt),
        }</span>
}

// convertActivityToProto converts a models.Activity to pb.Activity
func convertActivityToProto(activity *models.Activity) *pb.Activity <span class="cov0" title="0">{
        if activity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.Activity{
                Id:             activity.ID.String(),
                OrganizationId: activity.OrganizationID.String(),
                Type:           activity.Type,
                Status:         activity.Status,
                Parameters:     activity.Parameters,
                Result:         &amp;activity.Result,
                Intent:         convertActivityIntentToProto(&amp;activity.Intent),
                CreatedBy:      activity.CreatedBy.String(),
                CreatedAt:      timestamppb.New(activity.CreatedAt),
                UpdatedAt:      timestamppb.New(activity.UpdatedAt),
        }</span>
}

// convertActivityIntentToProto converts a models.ActivityIntent to pb.ActivityIntent
func convertActivityIntentToProto(intent *models.ActivityIntent) *pb.ActivityIntent <span class="cov0" title="0">{
        if intent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.ActivityIntent{
                Fingerprint: intent.Fingerprint,
                Summary:     intent.Summary,
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package grpc

import (
        "context"
        "fmt"
        "net"
        "time"

        pb "github.com/dojima-foundation/tee-auth/gauth/api/proto"
        "github.com/dojima-foundation/tee-auth/gauth/internal/service"
        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
        "github.com/dojima-foundation/tee-auth/gauth/pkg/logger"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/keepalive"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// Server represents the gRPC server
type Server struct {
        pb.UnimplementedGAuthServiceServer
        config  *config.Config
        logger  *logger.Logger
        service *service.GAuthService
        server  *grpc.Server
}

// NewServer creates a new gRPC server instance
func NewServer(cfg *config.Config, logger *logger.Logger, svc *service.GAuthService) *Server <span class="cov0" title="0">{
        return &amp;Server{
                config:  cfg,
                logger:  logger,
                service: svc,
        }
}</span>

// Start starts the gRPC server
func (s *Server) Start() error <span class="cov0" title="0">{
        // Create listener
        addr := s.config.GetGRPCAddr()
        listener, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", addr, err)
        }</span>

        // Configure gRPC server options
        <span class="cov0" title="0">opts := []grpc.ServerOption{
                grpc.MaxRecvMsgSize(s.config.GRPC.MaxRecvMsgSize),
                grpc.MaxSendMsgSize(s.config.GRPC.MaxSendMsgSize),
                grpc.KeepaliveParams(keepalive.ServerParameters{
                        Time:    s.config.GRPC.KeepAliveTime,
                        Timeout: s.config.GRPC.KeepAliveTimeout,
                }),
                grpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{
                        MinTime:             s.config.GRPC.KeepAliveTime,
                        PermitWithoutStream: s.config.GRPC.PermitWithoutStream,
                }),
                grpc.UnaryInterceptor(s.unaryInterceptor),
        }

        // Create gRPC server
        s.server = grpc.NewServer(opts...)

        // Register service
        pb.RegisterGAuthServiceServer(s.server, s)

        // Enable reflection for development
        reflection.Register(s.server)

        s.logger.Info("Starting gRPC server", "address", addr)

        // Start serving
        if err := s.server.Serve(listener); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve gRPC server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the gRPC server
func (s *Server) Stop() <span class="cov0" title="0">{
        if s.server != nil </span><span class="cov0" title="0">{
                s.logger.Info("Stopping gRPC server")
                s.server.GracefulStop()
        }</span>
}

// Unary interceptor for logging and error handling
func (s *Server) unaryInterceptor(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (interface{}, error) <span class="cov0" title="0">{
        start := time.Now()

        // Call the handler
        resp, err := handler(ctx, req)

        // Log the request
        duration := time.Since(start)
        s.logger.Info("gRPC request",
                "method", info.FullMethod,
                "duration", duration,
                "error", err,
        )

        return resp, err
}</span>

// Organization management methods

func (s *Server) CreateOrganization(ctx context.Context, req *pb.CreateOrganizationRequest) (*pb.CreateOrganizationResponse, error) <span class="cov0" title="0">{
        org, err := s.service.CreateOrganization(ctx, req.Name, req.InitialUserEmail, req.InitialUserPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create organization", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to create organization: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.CreateOrganizationResponse{
                Organization: convertOrganizationToProto(org),
                Status:       "created",
        }, nil</span>
}

func (s *Server) GetOrganization(ctx context.Context, req *pb.GetOrganizationRequest) (*pb.GetOrganizationResponse, error) <span class="cov0" title="0">{
        org, err := s.service.GetOrganization(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get organization", "error", err, "id", req.Id)
                return nil, status.Errorf(codes.NotFound, "organization not found: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetOrganizationResponse{
                Organization: convertOrganizationToProto(org),
        }, nil</span>
}

func (s *Server) UpdateOrganization(ctx context.Context, req *pb.UpdateOrganizationRequest) (*pb.UpdateOrganizationResponse, error) <span class="cov0" title="0">{
        org, err := s.service.UpdateOrganization(ctx, req.Id, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update organization", "error", err, "id", req.Id)
                return nil, status.Errorf(codes.Internal, "failed to update organization: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateOrganizationResponse{
                Organization: convertOrganizationToProto(org),
        }, nil</span>
}

func (s *Server) ListOrganizations(ctx context.Context, req *pb.ListOrganizationsRequest) (*pb.ListOrganizationsResponse, error) <span class="cov0" title="0">{
        orgs, nextToken, err := s.service.ListOrganizations(ctx, int(req.PageSize), req.PageToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list organizations", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to list organizations: %v", err)
        }</span>

        <span class="cov0" title="0">protoOrgs := make([]*pb.Organization, len(orgs))
        for i, org := range orgs </span><span class="cov0" title="0">{
                protoOrgs[i] = convertOrganizationToProto(&amp;org)
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListOrganizationsResponse{
                Organizations: protoOrgs,
                NextPageToken: nextToken,
        }, nil</span>
}

// User management methods

func (s *Server) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) <span class="cov0" title="0">{
        user, err := s.service.CreateUser(ctx, req.OrganizationId, req.Username, req.Email, req.PublicKey, req.Tags)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create user", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to create user: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.CreateUserResponse{
                User: convertUserToProto(user),
        }, nil</span>
}

func (s *Server) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) <span class="cov0" title="0">{
        user, err := s.service.GetUser(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user", "error", err, "id", req.Id)
                return nil, status.Errorf(codes.NotFound, "user not found: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetUserResponse{
                User: convertUserToProto(user),
        }, nil</span>
}

func (s *Server) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error) <span class="cov0" title="0">{
        user, err := s.service.UpdateUser(ctx, req.Id, req.Username, req.Email, req.Tags, req.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update user", "error", err, "id", req.Id)
                return nil, status.Errorf(codes.Internal, "failed to update user: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateUserResponse{
                User: convertUserToProto(user),
        }, nil</span>
}

func (s *Server) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) <span class="cov0" title="0">{
        users, nextToken, err := s.service.ListUsers(ctx, req.OrganizationId, int(req.PageSize), req.PageToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list users", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to list users: %v", err)
        }</span>

        <span class="cov0" title="0">protoUsers := make([]*pb.User, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                protoUsers[i] = convertUserToProto(&amp;user)
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListUsersResponse{
                Users:         protoUsers,
                NextPageToken: nextToken,
        }, nil</span>
}

// Activity management methods

func (s *Server) CreateActivity(ctx context.Context, req *pb.CreateActivityRequest) (*pb.CreateActivityResponse, error) <span class="cov0" title="0">{
        activity, err := s.service.CreateActivity(ctx, req.OrganizationId, req.Type, req.Parameters, req.CreatedBy)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create activity", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to create activity: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.CreateActivityResponse{
                Activity: convertActivityToProto(activity),
        }, nil</span>
}

func (s *Server) GetActivity(ctx context.Context, req *pb.GetActivityRequest) (*pb.GetActivityResponse, error) <span class="cov0" title="0">{
        activity, err := s.service.GetActivity(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get activity", "error", err, "id", req.Id)
                return nil, status.Errorf(codes.NotFound, "activity not found: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetActivityResponse{
                Activity: convertActivityToProto(activity),
        }, nil</span>
}

func (s *Server) ListActivities(ctx context.Context, req *pb.ListActivitiesRequest) (*pb.ListActivitiesResponse, error) <span class="cov0" title="0">{
        activities, nextToken, err := s.service.ListActivities(ctx, req.OrganizationId, req.Type, req.Status, int(req.PageSize), req.PageToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list activities", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to list activities: %v", err)
        }</span>

        <span class="cov0" title="0">protoActivities := make([]*pb.Activity, len(activities))
        for i, activity := range activities </span><span class="cov0" title="0">{
                protoActivities[i] = convertActivityToProto(&amp;activity)
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListActivitiesResponse{
                Activities:    protoActivities,
                NextPageToken: nextToken,
        }, nil</span>
}

// Communication with renclave-v2

func (s *Server) RequestSeedGeneration(ctx context.Context, req *pb.SeedGenerationRequest) (*pb.SeedGenerationResponse, error) <span class="cov0" title="0">{
        response, err := s.service.RequestSeedGeneration(ctx, req.OrganizationId, req.UserId, int(req.Strength), req.Passphrase)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to request seed generation", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to generate seed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.SeedGenerationResponse{
                SeedPhrase: response.SeedPhrase,
                Entropy:    response.Entropy,
                Strength:   int32(response.Strength),
                WordCount:  int32(response.WordCount),
                RequestId:  response.RequestID,
        }, nil</span>
}

func (s *Server) ValidateSeed(ctx context.Context, req *pb.SeedValidationRequest) (*pb.SeedValidationResponse, error) <span class="cov0" title="0">{
        response, err := s.service.ValidateSeed(ctx, req.SeedPhrase)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to validate seed", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to validate seed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.SeedValidationResponse{
                IsValid:   response.IsValid,
                Strength:  int32(response.Strength),
                WordCount: int32(response.WordCount),
                Errors:    response.Errors,
        }, nil</span>
}

func (s *Server) GetEnclaveInfo(ctx context.Context, req *emptypb.Empty) (*pb.EnclaveInfoResponse, error) <span class="cov0" title="0">{
        info, err := s.service.GetEnclaveInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get enclave info", "error", err)
                return nil, status.Errorf(codes.Internal, "failed to get enclave info: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.EnclaveInfoResponse{
                Version:      info.Version,
                EnclaveId:    info.EnclaveID,
                Capabilities: info.Capabilities,
                Healthy:      info.Healthy,
        }, nil</span>
}

// Authentication and authorization

func (s *Server) Authenticate(ctx context.Context, req *pb.AuthenticateRequest) (*pb.AuthenticateResponse, error) <span class="cov0" title="0">{
        response, err := s.service.Authenticate(ctx, req.OrganizationId, req.UserId, req.AuthMethodId, req.Signature, req.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Authentication failed", "error", err)
                return nil, status.Errorf(codes.Unauthenticated, "authentication failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.AuthenticateResponse{
                Authenticated: response.Authenticated,
                SessionToken:  response.SessionToken,
                ExpiresAt:     timestamppb.New(response.ExpiresAt),
                User:          convertUserToProto(response.User),
        }, nil</span>
}

func (s *Server) Authorize(ctx context.Context, req *pb.AuthorizeRequest) (*pb.AuthorizeResponse, error) <span class="cov0" title="0">{
        response, err := s.service.Authorize(ctx, req.SessionToken, req.ActivityType, req.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Authorization failed", "error", err)
                return nil, status.Errorf(codes.PermissionDenied, "authorization failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.AuthorizeResponse{
                Authorized:        response.Authorized,
                Reason:            response.Reason,
                RequiredApprovals: response.RequiredApprovals,
        }, nil</span>
}

// Health and status

func (s *Server) Health(ctx context.Context, req *emptypb.Empty) (*pb.HealthResponse, error) <span class="cov0" title="0">{
        health, err := s.service.Health(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Health check failed", "error", err)
                return nil, status.Errorf(codes.Internal, "health check failed: %v", err)
        }</span>

        <span class="cov0" title="0">services := make([]*pb.ServiceStatus, len(health.Services))
        for i, svc := range health.Services </span><span class="cov0" title="0">{
                services[i] = &amp;pb.ServiceStatus{
                        Name:   svc.Name,
                        Status: svc.Status,
                        Error:  svc.Error,
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.HealthResponse{
                Status:    health.Status,
                Services:  services,
                Timestamp: timestamppb.New(health.Timestamp),
        }, nil</span>
}

func (s *Server) Status(ctx context.Context, req *emptypb.Empty) (*pb.StatusResponse, error) <span class="cov0" title="0">{
        statusResp, err := s.service.Status(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Status check failed", "error", err)
                return nil, status.Errorf(codes.Internal, "status check failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.StatusResponse{
                Version:   statusResp.Version,
                BuildTime: statusResp.BuildTime,
                GitCommit: statusResp.GitCommit,
                Uptime:    timestamppb.New(statusResp.Uptime),
                Metrics:   statusResp.Metrics,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
)

// Organization represents the main data container following Turnkey's architecture
// Organizations encapsulate signing resources (Wallets and Private keys) as well as
// data relevant for authentication and authorization of their usage
type Organization struct {
        ID          uuid.UUID    `json:"uuid" db:"id" gorm:"type:uuid;primary_key"`
        Version     string       `json:"version" db:"version" gorm:"not null"`
        Name        string       `json:"name" db:"name" gorm:"not null"`
        Users       []User       `json:"users" db:"-" gorm:"foreignKey:OrganizationID"`
        RootQuorum  Quorum       `json:"rootQuorum" db:"-" gorm:"embedded;embeddedPrefix:root_quorum_"`
        Invitations []Invitation `json:"invitations" db:"-" gorm:"foreignKey:OrganizationID"`
        Policies    []Policy     `json:"policies" db:"-" gorm:"foreignKey:OrganizationID"`
        Tags        []Tag        `json:"tags" db:"-" gorm:"foreignKey:OrganizationID"`
        PrivateKeys []PrivateKey `json:"privateKeys" db:"-" gorm:"foreignKey:OrganizationID"`
        Wallets     []Wallet     `json:"wallets" db:"-" gorm:"foreignKey:OrganizationID"`
        CreatedAt   time.Time    `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt   time.Time    `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// User represents an authenticated entity within an organization
type User struct {
        ID             uuid.UUID    `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID    `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Username       string       `json:"username" db:"username" gorm:"not null"`
        Email          string       `json:"email" db:"email" gorm:"not null"`
        PublicKey      string       `json:"publicKey" db:"public_key" gorm:"not null"`
        AuthMethods    []AuthMethod `json:"authMethods" db:"-" gorm:"foreignKey:UserID"`
        Tags           []string     `json:"tags" db:"-" gorm:"-"`
        IsActive       bool         `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt      time.Time    `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time    `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// AuthMethod represents authentication methods for users
type AuthMethod struct {
        ID        uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        UserID    uuid.UUID `json:"userId" db:"user_id" gorm:"type:uuid;not null"`
        Type      string    `json:"type" db:"type" gorm:"not null"` // API_KEY, PASSKEY, OAUTH
        Name      string    `json:"name" db:"name" gorm:"not null"`
        Data      string    `json:"data" db:"data" gorm:"not null"` // JSON data specific to auth type
        IsActive  bool      `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt time.Time `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// Quorum defines the quorum requirements for critical operations
type Quorum struct {
        UserIDs   []uuid.UUID `json:"userIds" db:"-" gorm:"-"`
        Threshold int         `json:"threshold" db:"threshold" gorm:"not null"`
}

// Invitation represents pending invitations to join an organization
type Invitation struct {
        ID             uuid.UUID  `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID  `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Email          string     `json:"email" db:"email" gorm:"not null"`
        Role           string     `json:"role" db:"role" gorm:"not null"`
        Token          string     `json:"token" db:"token" gorm:"not null;unique"`
        ExpiresAt      time.Time  `json:"expiresAt" db:"expires_at" gorm:"not null"`
        AcceptedAt     *time.Time `json:"acceptedAt,omitempty" db:"accepted_at"`
        CreatedAt      time.Time  `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
}

// Policy represents authorization policies within an organization
type Policy struct {
        ID             uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Name           string    `json:"name" db:"name" gorm:"not null"`
        Description    string    `json:"description" db:"description"`
        Rules          string    `json:"rules" db:"rules" gorm:"type:text;not null"` // JSON policy rules
        IsActive       bool      `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt      time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// Tag represents categorization labels for resources
type Tag struct {
        ID             uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Name           string    `json:"name" db:"name" gorm:"not null"`
        Description    string    `json:"description" db:"description"`
        Color          string    `json:"color" db:"color"`
        CreatedAt      time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
}

// PrivateKey represents cryptographic private keys managed by the system
type PrivateKey struct {
        ID             uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Name           string    `json:"name" db:"name" gorm:"not null"`
        PublicKey      string    `json:"publicKey" db:"public_key" gorm:"not null"`
        Curve          string    `json:"curve" db:"curve" gorm:"not null"` // SECP256K1, ED25519, etc.
        Tags           []string  `json:"tags" db:"-" gorm:"-"`
        IsActive       bool      `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt      time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// Wallet represents HD wallets compliant with BIP39
type Wallet struct {
        ID             uuid.UUID       `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID       `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Name           string          `json:"name" db:"name" gorm:"not null"`
        PublicKey      string          `json:"publicKey" db:"public_key" gorm:"not null"`
        Accounts       []WalletAccount `json:"accounts" db:"-" gorm:"foreignKey:WalletID"`
        Tags           []string        `json:"tags" db:"-" gorm:"-"`
        IsActive       bool            `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt      time.Time       `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time       `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// WalletAccount represents individual accounts within an HD wallet
type WalletAccount struct {
        ID            uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        WalletID      uuid.UUID `json:"walletId" db:"wallet_id" gorm:"type:uuid;not null"`
        Name          string    `json:"name" db:"name" gorm:"not null"`
        Path          string    `json:"path" db:"path" gorm:"not null"` // BIP44 derivation path
        PublicKey     string    `json:"publicKey" db:"public_key" gorm:"not null"`
        Address       string    `json:"address" db:"address" gorm:"not null"`
        Curve         string    `json:"curve" db:"curve" gorm:"not null"`
        AddressFormat string    `json:"addressFormat" db:"address_format" gorm:"not null"`
        IsActive      bool      `json:"isActive" db:"is_active" gorm:"default:true"`
        CreatedAt     time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt     time.Time `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// Activity represents critical operations within the system
type Activity struct {
        ID             uuid.UUID      `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        OrganizationID uuid.UUID      `json:"organizationId" db:"organization_id" gorm:"type:uuid;not null"`
        Type           string         `json:"type" db:"type" gorm:"not null"`
        Status         string         `json:"status" db:"status" gorm:"not null"` // PENDING, COMPLETED, FAILED
        Parameters     string         `json:"parameters" db:"parameters" gorm:"type:jsonb"`
        Result         string         `json:"result,omitempty" db:"result" gorm:"type:jsonb"`
        Intent         ActivityIntent `json:"intent" db:"-" gorm:"embedded;embeddedPrefix:intent_"`
        CreatedBy      uuid.UUID      `json:"createdBy" db:"created_by" gorm:"type:uuid;not null"`
        CreatedAt      time.Time      `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
        UpdatedAt      time.Time      `json:"updatedAt" db:"updated_at" gorm:"autoUpdateTime"`
}

// ActivityIntent represents the parsed intent of an activity request
type ActivityIntent struct {
        Fingerprint string `json:"fingerprint" db:"fingerprint"`
        Summary     string `json:"summary" db:"summary"`
}

// Proof represents cryptographic proofs generated by the system
type Proof struct {
        ID         uuid.UUID `json:"id" db:"id" gorm:"type:uuid;primary_key"`
        ActivityID uuid.UUID `json:"activityId" db:"activity_id" gorm:"type:uuid;not null"`
        Type       string    `json:"type" db:"type" gorm:"not null"` // SIGNATURE, POLICY_OUTCOME, etc.
        Data       string    `json:"data" db:"data" gorm:"type:text;not null"`
        CreatedAt  time.Time `json:"createdAt" db:"created_at" gorm:"autoCreateTime"`
}

// ToJSON serializes the organization to JSON for storage/transmission
func (o *Organization) ToJSON() ([]byte, error) <span class="cov8" title="3">{
        return json.Marshal(o)
}</span>

// FromJSON deserializes JSON data into an organization
func (o *Organization) FromJSON(data []byte) error <span class="cov10" title="4">{
        return json.Unmarshal(data, o)
}</span>

// TableName returns the table name for GORM
func (Organization) TableName() string <span class="cov1" title="1">{
        return "organizations"
}</span>

func (User) TableName() string <span class="cov1" title="1">{
        return "users"
}</span>

func (AuthMethod) TableName() string <span class="cov1" title="1">{
        return "auth_methods"
}</span>

func (Invitation) TableName() string <span class="cov1" title="1">{
        return "invitations"
}</span>

func (Policy) TableName() string <span class="cov1" title="1">{
        return "policies"
}</span>

func (Tag) TableName() string <span class="cov1" title="1">{
        return "tags"
}</span>

func (PrivateKey) TableName() string <span class="cov1" title="1">{
        return "private_keys"
}</span>

func (Wallet) TableName() string <span class="cov1" title="1">{
        return "wallets"
}</span>

func (WalletAccount) TableName() string <span class="cov1" title="1">{
        return "wallet_accounts"
}</span>

func (Activity) TableName() string <span class="cov1" title="1">{
        return "activities"
}</span>

func (Proof) TableName() string <span class="cov1" title="1">{
        return "proofs"
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"
)

// RenclaveClient handles communication with the renclave-v2 service
type RenclaveClient struct {
        baseURL    string
        httpClient *http.Client
}

// NewRenclaveClient creates a new RenclaveClient instance
func NewRenclaveClient(baseURL string, timeout time.Duration) *RenclaveClient <span class="cov9" title="25">{
        return &amp;RenclaveClient{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: timeout,
                },
        }
}</span>

// Request and response types for renclave-v2 communication

type GenerateSeedRequest struct {
        Strength   int     `json:"strength"`
        Passphrase *string `json:"passphrase,omitempty"`
}

type GenerateSeedResponse struct {
        SeedPhrase string `json:"seed_phrase"`
        Entropy    string `json:"entropy"`
        Strength   int    `json:"strength"`
        WordCount  int    `json:"word_count"`
}

type ValidateSeedRequest struct {
        SeedPhrase string `json:"seed_phrase"`
}

type ValidateSeedResponse struct {
        IsValid   bool     `json:"is_valid"`
        Strength  int      `json:"strength"`
        WordCount int      `json:"word_count"`
        Errors    []string `json:"errors"`
}

type InfoResponse struct {
        Version      string   `json:"version"`
        EnclaveID    string   `json:"enclave_id"`
        Capabilities []string `json:"capabilities"`
        Healthy      bool     `json:"healthy"`
}

type HealthResponse struct {
        Status string `json:"status"`
}

// GenerateSeed requests seed generation from renclave-v2
func (c *RenclaveClient) GenerateSeed(ctx context.Context, strength int, passphrase *string) (*GenerateSeedResponse, error) <span class="cov5" title="5">{
        req := GenerateSeedRequest{
                Strength:   strength,
                Passphrase: passphrase,
        }

        var resp GenerateSeedResponse
        if err := c.makeRequest(ctx, "POST", "/generate-seed", req, &amp;resp); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to generate seed: %w", err)
        }</span>

        <span class="cov2" title="2">return &amp;resp, nil</span>
}

// ValidateSeed requests seed validation from renclave-v2
func (c *RenclaveClient) ValidateSeed(ctx context.Context, seedPhrase string) (*ValidateSeedResponse, error) <span class="cov5" title="5">{
        req := ValidateSeedRequest{
                SeedPhrase: seedPhrase,
        }

        var resp ValidateSeedResponse
        if err := c.makeRequest(ctx, "POST", "/validate-seed", req, &amp;resp); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to validate seed: %w", err)
        }</span>

        <span class="cov2" title="2">return &amp;resp, nil</span>
}

// GetInfo requests information from renclave-v2
func (c *RenclaveClient) GetInfo(ctx context.Context) (*InfoResponse, error) <span class="cov5" title="5">{
        var resp InfoResponse
        if err := c.makeRequest(ctx, "GET", "/info", nil, &amp;resp); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to get info: %w", err)
        }</span>

        <span class="cov2" title="2">return &amp;resp, nil</span>
}

// Health checks the health of renclave-v2
func (c *RenclaveClient) Health(ctx context.Context) error <span class="cov8" title="18">{
        var resp HealthResponse
        if err := c.makeRequest(ctx, "GET", "/health", nil, &amp;resp); err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov7" title="14">if resp.Status != "healthy" &amp;&amp; resp.Status != "ok" </span><span class="cov2" title="2">{
                return fmt.Errorf("renclave is unhealthy: %s", resp.Status)
        }</span>

        <span class="cov7" title="12">return nil</span>
}

// makeRequest is a helper method to make HTTP requests to renclave-v2
func (c *RenclaveClient) makeRequest(ctx context.Context, method, path string, reqBody interface{}, respBody interface{}) error <span class="cov10" title="33">{
        url := c.baseURL + path

        var body *bytes.Buffer
        if reqBody != nil </span><span class="cov6" title="10">{
                jsonData, err := json.Marshal(reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov6" title="10">body = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov10" title="33">var req *http.Request
        var err error
        if body != nil </span><span class="cov6" title="10">{
                req, err = http.NewRequestWithContext(ctx, method, url, body)
        }</span> else<span class="cov9" title="23"> {
                req, err = http.NewRequestWithContext(ctx, method, url, nil)
        }</span>
        <span class="cov10" title="33">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov10" title="33">if body != nil </span><span class="cov6" title="10">{
                req.Header.Set("Content-Type", "application/json")
        }</span>
        <span class="cov10" title="33">req.Header.Set("Accept", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov5" title="6">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov9" title="27">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov5" title="6">{
                return fmt.Errorf("request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="21">if respBody != nil </span><span class="cov8" title="21">{
                if err := json.NewDecoder(resp.Body).Decode(respBody); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to decode response body: %w", err)
                }</span>
        }

        <span class="cov8" title="20">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/dojima-foundation/tee-auth/gauth/internal/db"
        "github.com/dojima-foundation/tee-auth/gauth/internal/models"
        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
        "github.com/dojima-foundation/tee-auth/gauth/pkg/logger"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// GAuthService provides business logic for the gauth service
type GAuthService struct {
        config   *config.Config
        logger   *logger.Logger
        db       db.DatabaseInterface
        redis    db.RedisInterface
        renclave *RenclaveClient
}

// NewGAuthService creates a new GAuthService instance
func NewGAuthService(
        cfg *config.Config,
        logger *logger.Logger,
        database db.DatabaseInterface,
        redis db.RedisInterface,
) *GAuthService <span class="cov0" title="0">{
        renclave := NewRenclaveClient(cfg.GetRenclaveAddr(), cfg.Renclave.Timeout)

        return &amp;GAuthService{
                config:   cfg,
                logger:   logger,
                db:       database,
                redis:    redis,
                renclave: renclave,
        }
}</span>

// Organization management methods

func (s *GAuthService) CreateOrganization(ctx context.Context, name, initialUserEmail, initialUserPublicKey string) (*models.Organization, error) <span class="cov0" title="0">{
        s.logger.Info("Creating organization", "name", name, "initial_user_email", initialUserEmail)

        org := &amp;models.Organization{
                ID:      uuid.New(),
                Version: "1.0",
                Name:    name,
                RootQuorum: models.Quorum{
                        Threshold: s.config.Auth.DefaultQuorumThreshold,
                },
        }

        // Create initial user
        initialUser := models.User{
                ID:             uuid.New(),
                OrganizationID: org.ID,
                Username:       "admin",
                Email:          initialUserEmail,
                PublicKey:      initialUserPublicKey,
                IsActive:       true,
        }

        err := s.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Create organization
                if err := tx.Create(org).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create organization: %w", err)
                }</span>

                // Create initial user
                <span class="cov0" title="0">if err := tx.Create(&amp;initialUser).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create initial user: %w", err)
                }</span>

                // Add user to root quorum
                <span class="cov0" title="0">if err := tx.Create(&amp;QuorumMember{
                        OrganizationID: org.ID,
                        UserID:         initialUser.ID,
                }).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add user to quorum: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create organization", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("Organization created successfully", "organization_id", org.ID.String())
        return org, nil</span>
}

func (s *GAuthService) GetOrganization(ctx context.Context, id string) (*models.Organization, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">var org models.Organization
        if err := s.db.GetDB().WithContext(ctx).
                Preload("Users").
                Preload("Invitations").
                Preload("Policies").
                Preload("Tags").
                Preload("PrivateKeys").
                Preload("Wallets.Accounts").
                First(&amp;org, "id = ?", orgID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("organization not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organization: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;org, nil</span>
}

func (s *GAuthService) UpdateOrganization(ctx context.Context, id string, name *string) (*models.Organization, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">var org models.Organization
        if err := s.db.GetDB().WithContext(ctx).First(&amp;org, "id = ?", orgID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("organization not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organization: %w", err)</span>
        }

        <span class="cov0" title="0">if name != nil </span><span class="cov0" title="0">{
                org.Name = *name
        }</span>

        <span class="cov0" title="0">if err := s.db.GetDB().WithContext(ctx).Save(&amp;org).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update organization: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;org, nil</span>
}

func (s *GAuthService) ListOrganizations(ctx context.Context, pageSize int, pageToken string) ([]models.Organization, string, error) <span class="cov0" title="0">{
        if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">var orgs []models.Organization
        query := s.db.GetDB().WithContext(ctx).Limit(pageSize + 1) // +1 to check if there are more records

        if pageToken != "" </span><span class="cov0" title="0">{
                // Simple pagination using ID - in production, you might want to use cursor-based pagination
                if tokenID, err := uuid.Parse(pageToken); err == nil </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", tokenID)
                }</span>
        }

        <span class="cov0" title="0">if err := query.Find(&amp;orgs).Error; err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to list organizations: %w", err)
        }</span>

        <span class="cov0" title="0">var nextToken string
        if len(orgs) &gt; pageSize </span><span class="cov0" title="0">{
                nextToken = orgs[pageSize-1].ID.String()
                orgs = orgs[:pageSize]
        }</span>

        <span class="cov0" title="0">return orgs, nextToken, nil</span>
}

// User management methods

func (s *GAuthService) CreateUser(ctx context.Context, organizationID, username, email, publicKey string, tags []string) (*models.User, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                ID:             uuid.New(),
                OrganizationID: orgID,
                Username:       username,
                Email:          email,
                PublicKey:      publicKey,
                Tags:           tags,
                IsActive:       true,
        }

        if err := s.db.GetDB().WithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("User created", "user_id", user.ID.String(), "organization_id", organizationID)
        return user, nil</span>
}

func (s *GAuthService) GetUser(ctx context.Context, id string) (*models.User, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }</span>

        <span class="cov0" title="0">var user models.User
        if err := s.db.GetDB().WithContext(ctx).
                Preload("AuthMethods").
                First(&amp;user, "id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (s *GAuthService) UpdateUser(ctx context.Context, id string, username, email *string, tags []string, isActive *bool) (*models.User, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }</span>

        <span class="cov0" title="0">var user models.User
        if err := s.db.GetDB().WithContext(ctx).First(&amp;user, "id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">if username != nil </span><span class="cov0" title="0">{
                user.Username = *username
        }</span>
        <span class="cov0" title="0">if email != nil </span><span class="cov0" title="0">{
                user.Email = *email
        }</span>
        <span class="cov0" title="0">if tags != nil </span><span class="cov0" title="0">{
                user.Tags = tags
        }</span>
        <span class="cov0" title="0">if isActive != nil </span><span class="cov0" title="0">{
                user.IsActive = *isActive
        }</span>

        <span class="cov0" title="0">if err := s.db.GetDB().WithContext(ctx).Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (s *GAuthService) ListUsers(ctx context.Context, organizationID string, pageSize int, pageToken string) ([]models.User, string, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">var users []models.User
        query := s.db.GetDB().WithContext(ctx).
                Where("organization_id = ?", orgID).
                Limit(pageSize + 1)

        if pageToken != "" </span><span class="cov0" title="0">{
                if tokenID, err := uuid.Parse(pageToken); err == nil </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", tokenID)
                }</span>
        }

        <span class="cov0" title="0">if err := query.Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov0" title="0">var nextToken string
        if len(users) &gt; pageSize </span><span class="cov0" title="0">{
                nextToken = users[pageSize-1].ID.String()
                users = users[:pageSize]
        }</span>

        <span class="cov0" title="0">return users, nextToken, nil</span>
}

// Activity management methods

func (s *GAuthService) CreateActivity(ctx context.Context, organizationID, activityType, parameters, createdBy string) (*models.Activity, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">createdByID, err := uuid.Parse(createdBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid created_by user ID: %w", err)
        }</span>

        <span class="cov0" title="0">activity := &amp;models.Activity{
                ID:             uuid.New(),
                OrganizationID: orgID,
                Type:           activityType,
                Status:         "PENDING",
                Parameters:     parameters,
                CreatedBy:      createdByID,
        }

        if err := s.db.GetDB().WithContext(ctx).Create(activity).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create activity: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.LogActivity(activityType, activity.ID.String(), createdBy, organizationID)
        return activity, nil</span>
}

func (s *GAuthService) GetActivity(ctx context.Context, id string) (*models.Activity, error) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid activity ID: %w", err)
        }</span>

        <span class="cov0" title="0">var activity models.Activity
        if err := s.db.GetDB().WithContext(ctx).First(&amp;activity, "id = ?", activityID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("activity not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get activity: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;activity, nil</span>
}

func (s *GAuthService) ListActivities(ctx context.Context, organizationID string, activityType, status *string, pageSize int, pageToken string) ([]models.Activity, string, error) <span class="cov0" title="0">{
        orgID, err := uuid.Parse(organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("invalid organization ID: %w", err)
        }</span>

        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">query := s.db.GetDB().WithContext(ctx).
                Where("organization_id = ?", orgID).
                Limit(pageSize + 1)

        if activityType != nil </span><span class="cov0" title="0">{
                query = query.Where("type = ?", *activityType)
        }</span>
        <span class="cov0" title="0">if status != nil </span><span class="cov0" title="0">{
                query = query.Where("status = ?", *status)
        }</span>

        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                if tokenID, err := uuid.Parse(pageToken); err == nil </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", tokenID)
                }</span>
        }

        <span class="cov0" title="0">var activities []models.Activity
        if err := query.Find(&amp;activities).Error; err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to list activities: %w", err)
        }</span>

        <span class="cov0" title="0">var nextToken string
        if len(activities) &gt; pageSize </span><span class="cov0" title="0">{
                nextToken = activities[pageSize-1].ID.String()
                activities = activities[:pageSize]
        }</span>

        <span class="cov0" title="0">return activities, nextToken, nil</span>
}

// Response types for service methods
type SeedGenerationResponse struct {
        SeedPhrase string `json:"seed_phrase"`
        Entropy    string `json:"entropy"`
        Strength   int    `json:"strength"`
        WordCount  int    `json:"word_count"`
        RequestID  string `json:"request_id"`
}

type SeedValidationResponse struct {
        IsValid   bool     `json:"is_valid"`
        Strength  int      `json:"strength"`
        WordCount int      `json:"word_count"`
        Errors    []string `json:"errors"`
}

type EnclaveInfoResponse struct {
        Version      string   `json:"version"`
        EnclaveID    string   `json:"enclave_id"`
        Capabilities []string `json:"capabilities"`
        Healthy      bool     `json:"healthy"`
}

type AuthenticationResponse struct {
        Authenticated bool         `json:"authenticated"`
        SessionToken  string       `json:"session_token"`
        ExpiresAt     time.Time    `json:"expires_at"`
        User          *models.User `json:"user"`
}

type AuthorizationResponse struct {
        Authorized        bool     `json:"authorized"`
        Reason            string   `json:"reason"`
        RequiredApprovals []string `json:"required_approvals"`
}

type ServiceHealthResponse struct {
        Status    string          `json:"status"`
        Services  []ServiceStatus `json:"services"`
        Timestamp time.Time       `json:"timestamp"`
}

type ServiceStatus struct {
        Name   string  `json:"name"`
        Status string  `json:"status"`
        Error  *string `json:"error,omitempty"`
}

type StatusResponse struct {
        Version   string            `json:"version"`
        BuildTime string            `json:"build_time"`
        GitCommit string            `json:"git_commit"`
        Uptime    time.Time         `json:"uptime"`
        Metrics   map[string]string `json:"metrics"`
}

// Communication with renclave-v2

func (s *GAuthService) RequestSeedGeneration(ctx context.Context, organizationID, userID string, strength int, passphrase *string) (*SeedGenerationResponse, error) <span class="cov8" title="1">{
        s.logger.Info("Requesting seed generation",
                "organization_id", organizationID,
                "user_id", userID,
                "strength", strength,
        )

        response, err := s.renclave.GenerateSeed(ctx, strength, passphrase)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to generate seed", "error", err)
                return nil, fmt.Errorf("failed to generate seed: %w", err)
        }</span>

        // Log the activity
        <span class="cov0" title="0">s.logger.LogActivity("SEED_GENERATION", uuid.New().String(), userID, organizationID,
                "strength", strength,
                "has_passphrase", passphrase != nil,
        )

        return &amp;SeedGenerationResponse{
                SeedPhrase: response.SeedPhrase,
                Entropy:    response.Entropy,
                Strength:   response.Strength,
                WordCount:  response.WordCount,
                RequestID:  uuid.New().String(),
        }, nil</span>
}

func (s *GAuthService) ValidateSeed(ctx context.Context, seedPhrase string) (*SeedValidationResponse, error) <span class="cov8" title="1">{
        response, err := s.renclave.ValidateSeed(ctx, seedPhrase)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to validate seed", "error", err)
                return nil, fmt.Errorf("failed to validate seed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SeedValidationResponse{
                IsValid:   response.IsValid,
                Strength:  response.Strength,
                WordCount: response.WordCount,
                Errors:    response.Errors,
        }, nil</span>
}

func (s *GAuthService) GetEnclaveInfo(ctx context.Context) (*EnclaveInfoResponse, error) <span class="cov8" title="1">{
        info, err := s.renclave.GetInfo(ctx)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get enclave info", "error", err)
                return nil, fmt.Errorf("failed to get enclave info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;EnclaveInfoResponse{
                Version:      info.Version,
                EnclaveID:    info.EnclaveID,
                Capabilities: info.Capabilities,
                Healthy:      info.Healthy,
        }, nil</span>
}

// Authentication and authorization (placeholder implementations)

func (s *GAuthService) Authenticate(ctx context.Context, organizationID, userID, authMethodID, signature, timestamp string) (*AuthenticationResponse, error) <span class="cov0" title="0">{
        // This is a simplified implementation - in production you would:
        // 1. Verify the signature against the user's public key
        // 2. Check timestamp to prevent replay attacks
        // 3. Validate the auth method
        // 4. Create a session token

        user, err := s.GetUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sessionToken := uuid.New().String()
        expiresAt := time.Now().Add(s.config.Auth.SessionTimeout)

        // Store session in Redis
        if err := s.redis.SetSession(ctx, sessionToken, userID, s.config.Auth.SessionTimeout); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to store session", "error", err)
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.LogAuthenticationAttempt(userID, organizationID, true)

        return &amp;AuthenticationResponse{
                Authenticated: true,
                SessionToken:  sessionToken,
                ExpiresAt:     expiresAt,
                User:          user,
        }, nil</span>
}

func (s *GAuthService) Authorize(ctx context.Context, sessionToken, activityType, parameters string) (*AuthorizationResponse, error) <span class="cov0" title="0">{
        // This is a simplified implementation - in production you would:
        // 1. Validate the session token
        // 2. Get the user from the session
        // 3. Check policies and permissions
        // 4. Evaluate quorum requirements

        userID, err := s.redis.GetSession(ctx, sessionToken)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;AuthorizationResponse{
                        Authorized: false,
                        Reason:     "Invalid session",
                }, nil
        }</span>

        // Simple authorization - in production, implement policy engine
        <span class="cov0" title="0">_ = userID // Mark as used
        return &amp;AuthorizationResponse{
                Authorized:        true,
                Reason:            "Policy evaluation passed",
                RequiredApprovals: []string{}, // No additional approvals needed
        }, nil</span>
}

// Health and status

func (s *GAuthService) Health(ctx context.Context) (*ServiceHealthResponse, error) <span class="cov0" title="0">{
        services := []ServiceStatus{}

        // Check database health
        if err := s.db.Health(ctx); err != nil </span><span class="cov0" title="0">{
                errStr := err.Error()
                services = append(services, ServiceStatus{
                        Name:   "database",
                        Status: "unhealthy",
                        Error:  &amp;errStr,
                })
        }</span> else<span class="cov0" title="0"> {
                services = append(services, ServiceStatus{
                        Name:   "database",
                        Status: "healthy",
                })
        }</span>

        // Check Redis health
        <span class="cov0" title="0">if err := s.redis.Health(ctx); err != nil </span><span class="cov0" title="0">{
                errStr := err.Error()
                services = append(services, ServiceStatus{
                        Name:   "redis",
                        Status: "unhealthy",
                        Error:  &amp;errStr,
                })
        }</span> else<span class="cov0" title="0"> {
                services = append(services, ServiceStatus{
                        Name:   "redis",
                        Status: "healthy",
                })
        }</span>

        // Check renclave health
        <span class="cov0" title="0">if err := s.renclave.Health(ctx); err != nil </span><span class="cov0" title="0">{
                errStr := err.Error()
                services = append(services, ServiceStatus{
                        Name:   "renclave",
                        Status: "unhealthy",
                        Error:  &amp;errStr,
                })
        }</span> else<span class="cov0" title="0"> {
                services = append(services, ServiceStatus{
                        Name:   "renclave",
                        Status: "healthy",
                })
        }</span>

        // Determine overall status
        <span class="cov0" title="0">status := "healthy"
        for _, svc := range services </span><span class="cov0" title="0">{
                if svc.Status != "healthy" </span><span class="cov0" title="0">{
                        status = "degraded"
                        break</span>
                }
        }

        <span class="cov0" title="0">return &amp;ServiceHealthResponse{
                Status:    status,
                Services:  services,
                Timestamp: time.Now().UTC(),
        }, nil</span>
}

func (s *GAuthService) Status(ctx context.Context) (*StatusResponse, error) <span class="cov8" title="1">{
        return &amp;StatusResponse{
                Version:   "1.0.0",
                BuildTime: "2024-01-01T00:00:00Z", // This would be set at build time
                GitCommit: "unknown",              // This would be set at build time
                Uptime:    time.Now().UTC(),       // This would be the actual service start time
                Metrics: map[string]string{
                        "go_version": "go1.21",
                },
        }, nil
}</span>

// Helper types for database operations that might be missing
type QuorumMember struct {
        OrganizationID uuid.UUID `json:"organization_id" db:"organization_id" gorm:"type:uuid;not null"`
        UserID         uuid.UUID `json:"user_id" db:"user_id" gorm:"type:uuid;not null"`
}

func (QuorumMember) TableName() string <span class="cov0" title="0">{
        return "quorum_members"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration values for the gauth service
type Config struct {
        // Server configuration
        Server ServerConfig `yaml:"server"`

        // Database configuration
        Database DatabaseConfig `yaml:"database"`

        // Redis configuration
        Redis RedisConfig `yaml:"redis"`

        // gRPC configuration
        GRPC GRPCConfig `yaml:"grpc"`

        // Renclave configuration
        Renclave RenclaveConfig `yaml:"renclave"`

        // Authentication configuration
        Auth AuthConfig `yaml:"auth"`

        // Logging configuration
        Logging LoggingConfig `yaml:"logging"`

        // Security configuration
        Security SecurityConfig `yaml:"security"`
}

type ServerConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
        IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

type DatabaseConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        Username     string        `yaml:"username"`
        Password     string        `yaml:"password"`
        Database     string        `yaml:"database"`
        SSLMode      string        `yaml:"ssl_mode"`
        MaxOpenConns int           `yaml:"max_open_conns"`
        MaxIdleConns int           `yaml:"max_idle_conns"`
        MaxLifetime  time.Duration `yaml:"max_lifetime"`
}

type RedisConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        Password     string        `yaml:"password"`
        Database     int           `yaml:"database"`
        PoolSize     int           `yaml:"pool_size"`
        MinIdleConns int           `yaml:"min_idle_conns"`
        DialTimeout  time.Duration `yaml:"dial_timeout"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
}

type GRPCConfig struct {
        Host                string        `yaml:"host"`
        Port                int           `yaml:"port"`
        MaxRecvMsgSize      int           `yaml:"max_recv_msg_size"`
        MaxSendMsgSize      int           `yaml:"max_send_msg_size"`
        ConnectionTimeout   time.Duration `yaml:"connection_timeout"`
        KeepAliveTime       time.Duration `yaml:"keep_alive_time"`
        KeepAliveTimeout    time.Duration `yaml:"keep_alive_timeout"`
        PermitWithoutStream bool          `yaml:"permit_without_stream"`
}

type RenclaveConfig struct {
        Host    string        `yaml:"host"`
        Port    int           `yaml:"port"`
        UseTLS  bool          `yaml:"use_tls"`
        Timeout time.Duration `yaml:"timeout"`
}

type AuthConfig struct {
        JWTSecret              string        `yaml:"jwt_secret"`
        JWTExpiration          time.Duration `yaml:"jwt_expiration"`
        RefreshExpiration      time.Duration `yaml:"refresh_expiration"`
        SessionTimeout         time.Duration `yaml:"session_timeout"`
        MaxLoginAttempts       int           `yaml:"max_login_attempts"`
        LockoutDuration        time.Duration `yaml:"lockout_duration"`
        RequireQuorum          bool          `yaml:"require_quorum"`
        DefaultQuorumThreshold int           `yaml:"default_quorum_threshold"`
}

type LoggingConfig struct {
        Level      string `yaml:"level"`
        Format     string `yaml:"format"` // json, text
        Output     string `yaml:"output"` // stdout, stderr, file
        Filename   string `yaml:"filename"`
        MaxSize    int    `yaml:"max_size"`
        MaxBackups int    `yaml:"max_backups"`
        MaxAge     int    `yaml:"max_age"`
        Compress   bool   `yaml:"compress"`
}

type SecurityConfig struct {
        TLSEnabled       bool     `yaml:"tls_enabled"`
        TLSCertFile      string   `yaml:"tls_cert_file"`
        TLSKeyFile       string   `yaml:"tls_key_file"`
        CORSEnabled      bool     `yaml:"cors_enabled"`
        CORSOrigins      []string `yaml:"cors_origins"`
        RateLimitEnabled bool     `yaml:"rate_limit_enabled"`
        RateLimitRPS     int      `yaml:"rate_limit_rps"`
        RateLimitBurst   int      `yaml:"rate_limit_burst"`
        EncryptionKey    string   `yaml:"encryption_key"`
}

// Load loads configuration from environment variables and .env file
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        if _, err := os.Stat(".env"); err == nil </span><span class="cov0" title="0">{
                if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load .env file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">config := &amp;Config{
                Server: ServerConfig{
                        Host:         getEnv("SERVER_HOST", "0.0.0.0"),
                        Port:         getEnvInt("SERVER_PORT", 8080),
                        ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 30*time.Second),
                        WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 30*time.Second),
                        IdleTimeout:  getEnvDuration("SERVER_IDLE_TIMEOUT", 120*time.Second),
                },
                Database: DatabaseConfig{
                        Host:         getEnv("DB_HOST", "localhost"),
                        Port:         getEnvInt("DB_PORT", 5432),
                        Username:     getEnv("DB_USERNAME", "gauth"),
                        Password:     getEnv("DB_PASSWORD", "password"),
                        Database:     getEnv("DB_DATABASE", "gauth"),
                        SSLMode:      getEnv("DB_SSL_MODE", "disable"),
                        MaxOpenConns: getEnvInt("DB_MAX_OPEN_CONNS", 25),
                        MaxIdleConns: getEnvInt("DB_MAX_IDLE_CONNS", 5),
                        MaxLifetime:  getEnvDuration("DB_MAX_LIFETIME", 5*time.Minute),
                },
                Redis: RedisConfig{
                        Host:         getEnv("REDIS_HOST", "localhost"),
                        Port:         getEnvInt("REDIS_PORT", 6379),
                        Password:     getEnv("REDIS_PASSWORD", ""),
                        Database:     getEnvInt("REDIS_DATABASE", 0),
                        PoolSize:     getEnvInt("REDIS_POOL_SIZE", 10),
                        MinIdleConns: getEnvInt("REDIS_MIN_IDLE_CONNS", 5),
                        DialTimeout:  getEnvDuration("REDIS_DIAL_TIMEOUT", 5*time.Second),
                        ReadTimeout:  getEnvDuration("REDIS_READ_TIMEOUT", 3*time.Second),
                        WriteTimeout: getEnvDuration("REDIS_WRITE_TIMEOUT", 3*time.Second),
                },
                GRPC: GRPCConfig{
                        Host:                getEnv("GRPC_HOST", "0.0.0.0"),
                        Port:                getEnvInt("GRPC_PORT", 9090),
                        MaxRecvMsgSize:      getEnvInt("GRPC_MAX_RECV_MSG_SIZE", 4*1024*1024), // 4MB
                        MaxSendMsgSize:      getEnvInt("GRPC_MAX_SEND_MSG_SIZE", 4*1024*1024), // 4MB
                        ConnectionTimeout:   getEnvDuration("GRPC_CONNECTION_TIMEOUT", 10*time.Second),
                        KeepAliveTime:       getEnvDuration("GRPC_KEEP_ALIVE_TIME", 30*time.Second),
                        KeepAliveTimeout:    getEnvDuration("GRPC_KEEP_ALIVE_TIMEOUT", 5*time.Second),
                        PermitWithoutStream: getEnvBool("GRPC_PERMIT_WITHOUT_STREAM", true),
                },
                Renclave: RenclaveConfig{
                        Host:    getEnv("RENCLAVE_HOST", "localhost"),
                        Port:    getEnvInt("RENCLAVE_PORT", 3000),
                        UseTLS:  getEnvBool("RENCLAVE_USE_TLS", false),
                        Timeout: getEnvDuration("RENCLAVE_TIMEOUT", 30*time.Second),
                },
                Auth: AuthConfig{
                        JWTSecret:              getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
                        JWTExpiration:          getEnvDuration("JWT_EXPIRATION", 24*time.Hour),
                        RefreshExpiration:      getEnvDuration("REFRESH_EXPIRATION", 7*24*time.Hour),
                        SessionTimeout:         getEnvDuration("SESSION_TIMEOUT", 30*time.Minute),
                        MaxLoginAttempts:       getEnvInt("MAX_LOGIN_ATTEMPTS", 5),
                        LockoutDuration:        getEnvDuration("LOCKOUT_DURATION", 15*time.Minute),
                        RequireQuorum:          getEnvBool("REQUIRE_QUORUM", false),
                        DefaultQuorumThreshold: getEnvInt("DEFAULT_QUORUM_THRESHOLD", 1),
                },
                Logging: LoggingConfig{
                        Level:      getEnv("LOG_LEVEL", "info"),
                        Format:     getEnv("LOG_FORMAT", "json"),
                        Output:     getEnv("LOG_OUTPUT", "stdout"),
                        Filename:   getEnv("LOG_FILENAME", "gauth.log"),
                        MaxSize:    getEnvInt("LOG_MAX_SIZE", 100),
                        MaxBackups: getEnvInt("LOG_MAX_BACKUPS", 3),
                        MaxAge:     getEnvInt("LOG_MAX_AGE", 28),
                        Compress:   getEnvBool("LOG_COMPRESS", true),
                },
                Security: SecurityConfig{
                        TLSEnabled:       getEnvBool("TLS_ENABLED", false),
                        TLSCertFile:      getEnv("TLS_CERT_FILE", ""),
                        TLSKeyFile:       getEnv("TLS_KEY_FILE", ""),
                        CORSEnabled:      getEnvBool("CORS_ENABLED", true),
                        CORSOrigins:      getEnvStringSlice("CORS_ORIGINS", []string{"*"}),
                        RateLimitEnabled: getEnvBool("RATE_LIMIT_ENABLED", true),
                        RateLimitRPS:     getEnvInt("RATE_LIMIT_RPS", 100),
                        RateLimitBurst:   getEnvInt("RATE_LIMIT_BURST", 200),
                        EncryptionKey:    getEnv("ENCRYPTION_KEY", "your-encryption-key-32-bytes-long"),
                },
        }

        // Validate required configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Database.Username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database username is required")
        }</span>
        <span class="cov0" title="0">if c.Database.Database == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>
        <span class="cov0" title="0">if c.Auth.JWTSecret == "" || c.Auth.JWTSecret == "your-secret-key-change-in-production" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret must be set to a secure value")
        }</span>
        <span class="cov0" title="0">if len(c.Security.EncryptionKey) != 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("encryption key must be exactly 32 bytes long")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDatabaseDSN returns the database connection string
func (c *Config) GetDatabaseDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Database.Host,
                c.Database.Port,
                c.Database.Username,
                c.Database.Password,
                c.Database.Database,
                c.Database.SSLMode,
        )
}</span>

// GetRedisAddr returns the Redis connection address
func (c *Config) GetRedisAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Redis.Host, c.Redis.Port)
}</span>

// GetServerAddr returns the server address
func (c *Config) GetServerAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetGRPCAddr returns the gRPC server address
func (c *Config) GetGRPCAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.GRPC.Host, c.GRPC.Port)
}</span>

// GetRenclaveAddr returns the renclave service address
func (c *Config) GetRenclaveAddr() string <span class="cov0" title="0">{
        protocol := "http"
        if c.Renclave.UseTLS </span><span class="cov0" title="0">{
                protocol = "https"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s://%s:%d", protocol, c.Renclave.Host, c.Renclave.Port)</span>
}

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvStringSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                // Simple comma-separated parsing
                // For production, consider using a more robust parser
                return []string{value}
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"

        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
)

// Logger represents a structured logger
type Logger struct {
        *slog.Logger
}

// New creates a new logger instance based on configuration
func New(cfg *config.LoggingConfig) (*Logger, error) <span class="cov0" title="0">{
        var level slog.Level
        switch cfg.Level </span>{
        case "debug":<span class="cov0" title="0">
                level = slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        case "warn", "warning":<span class="cov0" title="0">
                level = slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        }

        <span class="cov0" title="0">var writer io.Writer
        switch cfg.Output </span>{
        case "stdout":<span class="cov0" title="0">
                writer = os.Stdout</span>
        case "stderr":<span class="cov0" title="0">
                writer = os.Stderr</span>
        case "file":<span class="cov0" title="0">
                if cfg.Filename == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("filename is required when output is 'file'")
                }</span>
                <span class="cov0" title="0">file, err := os.OpenFile(cfg.Filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open log file: %w", err)
                }</span>
                <span class="cov0" title="0">writer = file</span>
        default:<span class="cov0" title="0">
                writer = os.Stdout</span>
        }

        <span class="cov0" title="0">var handler slog.Handler
        opts := &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: true,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        // Add timestamp formatting
                        if a.Key == slog.TimeKey </span><span class="cov0" title="0">{
                                a.Value = slog.StringValue(time.Now().UTC().Format(time.RFC3339))
                        }</span>
                        <span class="cov0" title="0">return a</span>
                },
        }

        <span class="cov0" title="0">switch cfg.Format </span>{
        case "json":<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        case "text":<span class="cov0" title="0">
                handler = slog.NewTextHandler(writer, opts)</span>
        default:<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        }

        <span class="cov0" title="0">logger := slog.New(handler)

        return &amp;Logger{Logger: logger}, nil</span>
}

// NewDefault creates a default logger for development
func NewDefault() *Logger <span class="cov10" title="4">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:     slog.LevelInfo,
                AddSource: true,
        })
        logger := slog.New(handler)
        return &amp;Logger{Logger: logger}
}</span>

// WithFields adds structured fields to the logger
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov0" title="0">{
        args := make([]interface{}, 0, len(fields)*2)
        for k, v := range fields </span><span class="cov0" title="0">{
                args = append(args, k, v)
        }</span>
        <span class="cov0" title="0">return &amp;Logger{Logger: l.Logger.With(args...)}</span>
}

// WithField adds a single structured field to the logger
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With(key, value)}
}</span>

// WithError adds an error field to the logger
func (l *Logger) WithError(err error) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With("error", err)}
}</span>

// Convenience methods for different log levels with key-value pairs

func (l *Logger) Debug(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Debug(msg, keysAndValues...)
}</span>

func (l *Logger) Info(msg string, keysAndValues ...interface{}) <span class="cov1" title="1">{
        l.Logger.Info(msg, keysAndValues...)
}</span>

func (l *Logger) Warn(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Warn(msg, keysAndValues...)
}</span>

func (l *Logger) Error(msg string, keysAndValues ...interface{}) <span class="cov8" title="3">{
        l.Logger.Error(msg, keysAndValues...)
}</span>

// HTTP request logging helpers

func (l *Logger) LogHTTPRequest(method, path string, statusCode int, duration time.Duration, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "method", method,
                "path", path,
                "status_code", statusCode,
                "duration_ms", duration.Milliseconds(),
        }
        args = append(args, keysAndValues...)
        l.Logger.Info("HTTP request", args...)
}</span>

func (l *Logger) LogGRPCRequest(method string, duration time.Duration, err error, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "grpc_method", method,
                "duration_ms", duration.Milliseconds(),
        }
        if err != nil </span><span class="cov0" title="0">{
                args = append(args, "error", err.Error())
        }</span>
        <span class="cov0" title="0">args = append(args, keysAndValues...)

        if err != nil </span><span class="cov0" title="0">{
                l.Logger.Error("gRPC request failed", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Info("gRPC request", args...)
        }</span>
}

// Database operation logging helpers

func (l *Logger) LogDatabaseQuery(query string, duration time.Duration, err error, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "query", query,
                "duration_ms", duration.Milliseconds(),
        }
        if err != nil </span><span class="cov0" title="0">{
                args = append(args, "error", err.Error())
        }</span>
        <span class="cov0" title="0">args = append(args, keysAndValues...)

        if err != nil </span><span class="cov0" title="0">{
                l.Logger.Error("Database query failed", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Debug("Database query", args...)
        }</span>
}

// Security event logging

func (l *Logger) LogSecurityEvent(event string, userID, organizationID string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "security_event", event,
                "user_id", userID,
                "organization_id", organizationID,
        }
        args = append(args, keysAndValues...)
        l.Logger.Warn("Security event", args...)
}</span>

func (l *Logger) LogAuthenticationAttempt(userID, organizationID string, success bool, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "authentication_attempt", true,
                "user_id", userID,
                "organization_id", organizationID,
                "success", success,
        }
        args = append(args, keysAndValues...)

        if success </span><span class="cov0" title="0">{
                l.Logger.Info("Authentication successful", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Warn("Authentication failed", args...)
        }</span>
}

func (l *Logger) LogAuthorizationAttempt(userID, organizationID, activityType string, success bool, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "authorization_attempt", true,
                "user_id", userID,
                "organization_id", organizationID,
                "activity_type", activityType,
                "success", success,
        }
        args = append(args, keysAndValues...)

        if success </span><span class="cov0" title="0">{
                l.Logger.Info("Authorization successful", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Warn("Authorization failed", args...)
        }</span>
}

// Activity logging

func (l *Logger) LogActivity(activityType, activityID, userID, organizationID string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "activity_type", activityType,
                "activity_id", activityID,
                "user_id", userID,
                "organization_id", organizationID,
        }
        args = append(args, keysAndValues...)
        l.Logger.Info("Activity executed", args...)
}</span>

// Service health logging

func (l *Logger) LogServiceHealth(serviceName, status string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "service_name", serviceName,
                "health_status", status,
        }
        args = append(args, keysAndValues...)

        if status == "healthy" </span><span class="cov0" title="0">{
                l.Logger.Debug("Service health check", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Error("Service unhealthy", args...)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
