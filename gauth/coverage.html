
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dojima-foundation/tee-auth/gauth/pkg/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/dojima-foundation/tee-auth/gauth/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration values for the gauth service
type Config struct {
        // Server configuration
        Server ServerConfig `yaml:"server"`

        // Database configuration
        Database DatabaseConfig `yaml:"database"`

        // Redis configuration
        Redis RedisConfig `yaml:"redis"`

        // gRPC configuration
        GRPC GRPCConfig `yaml:"grpc"`

        // Renclave configuration
        Renclave RenclaveConfig `yaml:"renclave"`

        // Authentication configuration
        Auth AuthConfig `yaml:"auth"`

        // Logging configuration
        Logging LoggingConfig `yaml:"logging"`

        // Security configuration
        Security SecurityConfig `yaml:"security"`
}

type ServerConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
        IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

type DatabaseConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        Username     string        `yaml:"username"`
        Password     string        `yaml:"password"`
        Database     string        `yaml:"database"`
        SSLMode      string        `yaml:"ssl_mode"`
        MaxOpenConns int           `yaml:"max_open_conns"`
        MaxIdleConns int           `yaml:"max_idle_conns"`
        MaxLifetime  time.Duration `yaml:"max_lifetime"`
}

type RedisConfig struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        Password     string        `yaml:"password"`
        Database     int           `yaml:"database"`
        PoolSize     int           `yaml:"pool_size"`
        MinIdleConns int           `yaml:"min_idle_conns"`
        DialTimeout  time.Duration `yaml:"dial_timeout"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
}

type GRPCConfig struct {
        Host                string        `yaml:"host"`
        Port                int           `yaml:"port"`
        MaxRecvMsgSize      int           `yaml:"max_recv_msg_size"`
        MaxSendMsgSize      int           `yaml:"max_send_msg_size"`
        ConnectionTimeout   time.Duration `yaml:"connection_timeout"`
        KeepAliveTime       time.Duration `yaml:"keep_alive_time"`
        KeepAliveTimeout    time.Duration `yaml:"keep_alive_timeout"`
        PermitWithoutStream bool          `yaml:"permit_without_stream"`
}

type RenclaveConfig struct {
        Host    string        `yaml:"host"`
        Port    int           `yaml:"port"`
        UseTLS  bool          `yaml:"use_tls"`
        Timeout time.Duration `yaml:"timeout"`
}

type AuthConfig struct {
        JWTSecret              string        `yaml:"jwt_secret"`
        JWTExpiration          time.Duration `yaml:"jwt_expiration"`
        RefreshExpiration      time.Duration `yaml:"refresh_expiration"`
        SessionTimeout         time.Duration `yaml:"session_timeout"`
        MaxLoginAttempts       int           `yaml:"max_login_attempts"`
        LockoutDuration        time.Duration `yaml:"lockout_duration"`
        RequireQuorum          bool          `yaml:"require_quorum"`
        DefaultQuorumThreshold int           `yaml:"default_quorum_threshold"`
}

type LoggingConfig struct {
        Level      string `yaml:"level"`
        Format     string `yaml:"format"` // json, text
        Output     string `yaml:"output"` // stdout, stderr, file
        Filename   string `yaml:"filename"`
        MaxSize    int    `yaml:"max_size"`
        MaxBackups int    `yaml:"max_backups"`
        MaxAge     int    `yaml:"max_age"`
        Compress   bool   `yaml:"compress"`
}

type SecurityConfig struct {
        TLSEnabled       bool     `yaml:"tls_enabled"`
        TLSCertFile      string   `yaml:"tls_cert_file"`
        TLSKeyFile       string   `yaml:"tls_key_file"`
        CORSEnabled      bool     `yaml:"cors_enabled"`
        CORSOrigins      []string `yaml:"cors_origins"`
        RateLimitEnabled bool     `yaml:"rate_limit_enabled"`
        RateLimitRPS     int      `yaml:"rate_limit_rps"`
        RateLimitBurst   int      `yaml:"rate_limit_burst"`
        EncryptionKey    string   `yaml:"encryption_key"`
}

// Load loads configuration from environment variables and .env file
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        if _, err := os.Stat(".env"); err == nil </span><span class="cov0" title="0">{
                if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load .env file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">config := &amp;Config{
                Server: ServerConfig{
                        Host:         getEnv("SERVER_HOST", "0.0.0.0"),
                        Port:         getEnvInt("SERVER_PORT", 8080),
                        ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 30*time.Second),
                        WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 30*time.Second),
                        IdleTimeout:  getEnvDuration("SERVER_IDLE_TIMEOUT", 120*time.Second),
                },
                Database: DatabaseConfig{
                        Host:         getEnv("DB_HOST", "localhost"),
                        Port:         getEnvInt("DB_PORT", 5432),
                        Username:     getEnv("DB_USERNAME", "gauth"),
                        Password:     getEnv("DB_PASSWORD", "password"),
                        Database:     getEnv("DB_DATABASE", "gauth"),
                        SSLMode:      getEnv("DB_SSL_MODE", "disable"),
                        MaxOpenConns: getEnvInt("DB_MAX_OPEN_CONNS", 25),
                        MaxIdleConns: getEnvInt("DB_MAX_IDLE_CONNS", 5),
                        MaxLifetime:  getEnvDuration("DB_MAX_LIFETIME", 5*time.Minute),
                },
                Redis: RedisConfig{
                        Host:         getEnv("REDIS_HOST", "localhost"),
                        Port:         getEnvInt("REDIS_PORT", 6379),
                        Password:     getEnv("REDIS_PASSWORD", ""),
                        Database:     getEnvInt("REDIS_DATABASE", 0),
                        PoolSize:     getEnvInt("REDIS_POOL_SIZE", 10),
                        MinIdleConns: getEnvInt("REDIS_MIN_IDLE_CONNS", 5),
                        DialTimeout:  getEnvDuration("REDIS_DIAL_TIMEOUT", 5*time.Second),
                        ReadTimeout:  getEnvDuration("REDIS_READ_TIMEOUT", 3*time.Second),
                        WriteTimeout: getEnvDuration("REDIS_WRITE_TIMEOUT", 3*time.Second),
                },
                GRPC: GRPCConfig{
                        Host:                getEnv("GRPC_HOST", "0.0.0.0"),
                        Port:                getEnvInt("GRPC_PORT", 9090),
                        MaxRecvMsgSize:      getEnvInt("GRPC_MAX_RECV_MSG_SIZE", 4*1024*1024), // 4MB
                        MaxSendMsgSize:      getEnvInt("GRPC_MAX_SEND_MSG_SIZE", 4*1024*1024), // 4MB
                        ConnectionTimeout:   getEnvDuration("GRPC_CONNECTION_TIMEOUT", 10*time.Second),
                        KeepAliveTime:       getEnvDuration("GRPC_KEEP_ALIVE_TIME", 30*time.Second),
                        KeepAliveTimeout:    getEnvDuration("GRPC_KEEP_ALIVE_TIMEOUT", 5*time.Second),
                        PermitWithoutStream: getEnvBool("GRPC_PERMIT_WITHOUT_STREAM", true),
                },
                Renclave: RenclaveConfig{
                        Host:    getEnv("RENCLAVE_HOST", "localhost"),
                        Port:    getEnvInt("RENCLAVE_PORT", 3000),
                        UseTLS:  getEnvBool("RENCLAVE_USE_TLS", false),
                        Timeout: getEnvDuration("RENCLAVE_TIMEOUT", 30*time.Second),
                },
                Auth: AuthConfig{
                        JWTSecret:              getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
                        JWTExpiration:          getEnvDuration("JWT_EXPIRATION", 24*time.Hour),
                        RefreshExpiration:      getEnvDuration("REFRESH_EXPIRATION", 7*24*time.Hour),
                        SessionTimeout:         getEnvDuration("SESSION_TIMEOUT", 30*time.Minute),
                        MaxLoginAttempts:       getEnvInt("MAX_LOGIN_ATTEMPTS", 5),
                        LockoutDuration:        getEnvDuration("LOCKOUT_DURATION", 15*time.Minute),
                        RequireQuorum:          getEnvBool("REQUIRE_QUORUM", false),
                        DefaultQuorumThreshold: getEnvInt("DEFAULT_QUORUM_THRESHOLD", 1),
                },
                Logging: LoggingConfig{
                        Level:      getEnv("LOG_LEVEL", "info"),
                        Format:     getEnv("LOG_FORMAT", "json"),
                        Output:     getEnv("LOG_OUTPUT", "stdout"),
                        Filename:   getEnv("LOG_FILENAME", "gauth.log"),
                        MaxSize:    getEnvInt("LOG_MAX_SIZE", 100),
                        MaxBackups: getEnvInt("LOG_MAX_BACKUPS", 3),
                        MaxAge:     getEnvInt("LOG_MAX_AGE", 28),
                        Compress:   getEnvBool("LOG_COMPRESS", true),
                },
                Security: SecurityConfig{
                        TLSEnabled:       getEnvBool("TLS_ENABLED", false),
                        TLSCertFile:      getEnv("TLS_CERT_FILE", ""),
                        TLSKeyFile:       getEnv("TLS_KEY_FILE", ""),
                        CORSEnabled:      getEnvBool("CORS_ENABLED", true),
                        CORSOrigins:      getEnvStringSlice("CORS_ORIGINS", []string{"*"}),
                        RateLimitEnabled: getEnvBool("RATE_LIMIT_ENABLED", true),
                        RateLimitRPS:     getEnvInt("RATE_LIMIT_RPS", 100),
                        RateLimitBurst:   getEnvInt("RATE_LIMIT_BURST", 200),
                        EncryptionKey:    getEnv("ENCRYPTION_KEY", "your-encryption-key-32-bytes-long"),
                },
        }

        // Validate required configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Database.Username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database username is required")
        }</span>
        <span class="cov0" title="0">if c.Database.Database == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>
        <span class="cov0" title="0">if c.Auth.JWTSecret == "" || c.Auth.JWTSecret == "your-secret-key-change-in-production" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret must be set to a secure value")
        }</span>
        <span class="cov0" title="0">if len(c.Security.EncryptionKey) != 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("encryption key must be exactly 32 bytes long")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDatabaseDSN returns the database connection string
func (c *Config) GetDatabaseDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Database.Host,
                c.Database.Port,
                c.Database.Username,
                c.Database.Password,
                c.Database.Database,
                c.Database.SSLMode,
        )
}</span>

// GetRedisAddr returns the Redis connection address
func (c *Config) GetRedisAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Redis.Host, c.Redis.Port)
}</span>

// GetServerAddr returns the server address
func (c *Config) GetServerAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetGRPCAddr returns the gRPC server address
func (c *Config) GetGRPCAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.GRPC.Host, c.GRPC.Port)
}</span>

// GetRenclaveAddr returns the renclave service address
func (c *Config) GetRenclaveAddr() string <span class="cov0" title="0">{
        protocol := "http"
        if c.Renclave.UseTLS </span><span class="cov0" title="0">{
                protocol = "https"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s://%s:%d", protocol, c.Renclave.Host, c.Renclave.Port)</span>
}

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvStringSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                // Simple comma-separated parsing
                // For production, consider using a more robust parser
                return []string{value}
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package logger

import (
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"

        "github.com/dojima-foundation/tee-auth/gauth/pkg/config"
)

// Logger represents a structured logger
type Logger struct {
        *slog.Logger
}

// New creates a new logger instance based on configuration
func New(cfg *config.LoggingConfig) (*Logger, error) <span class="cov0" title="0">{
        var level slog.Level
        switch cfg.Level </span>{
        case "debug":<span class="cov0" title="0">
                level = slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        case "warn", "warning":<span class="cov0" title="0">
                level = slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        }

        <span class="cov0" title="0">var writer io.Writer
        switch cfg.Output </span>{
        case "stdout":<span class="cov0" title="0">
                writer = os.Stdout</span>
        case "stderr":<span class="cov0" title="0">
                writer = os.Stderr</span>
        case "file":<span class="cov0" title="0">
                if cfg.Filename == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("filename is required when output is 'file'")
                }</span>
                <span class="cov0" title="0">file, err := os.OpenFile(cfg.Filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open log file: %w", err)
                }</span>
                <span class="cov0" title="0">writer = file</span>
        default:<span class="cov0" title="0">
                writer = os.Stdout</span>
        }

        <span class="cov0" title="0">var handler slog.Handler
        opts := &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: true,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        // Add timestamp formatting
                        if a.Key == slog.TimeKey </span><span class="cov0" title="0">{
                                a.Value = slog.StringValue(time.Now().UTC().Format(time.RFC3339))
                        }</span>
                        <span class="cov0" title="0">return a</span>
                },
        }

        <span class="cov0" title="0">switch cfg.Format </span>{
        case "json":<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        case "text":<span class="cov0" title="0">
                handler = slog.NewTextHandler(writer, opts)</span>
        default:<span class="cov0" title="0">
                handler = slog.NewJSONHandler(writer, opts)</span>
        }

        <span class="cov0" title="0">logger := slog.New(handler)

        return &amp;Logger{Logger: logger}, nil</span>
}

// NewDefault creates a default logger for development
func NewDefault() *Logger <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:     slog.LevelInfo,
                AddSource: true,
        })
        logger := slog.New(handler)
        return &amp;Logger{Logger: logger}
}</span>

// WithFields adds structured fields to the logger
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov0" title="0">{
        args := make([]interface{}, 0, len(fields)*2)
        for k, v := range fields </span><span class="cov0" title="0">{
                args = append(args, k, v)
        }</span>
        <span class="cov0" title="0">return &amp;Logger{Logger: l.Logger.With(args...)}</span>
}

// WithField adds a single structured field to the logger
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With(key, value)}
}</span>

// WithError adds an error field to the logger
func (l *Logger) WithError(err error) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With("error", err)}
}</span>

// Convenience methods for different log levels with key-value pairs

func (l *Logger) Debug(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Debug(msg, keysAndValues...)
}</span>

func (l *Logger) Info(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Info(msg, keysAndValues...)
}</span>

func (l *Logger) Warn(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Warn(msg, keysAndValues...)
}</span>

func (l *Logger) Error(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.Logger.Error(msg, keysAndValues...)
}</span>

// HTTP request logging helpers

func (l *Logger) LogHTTPRequest(method, path string, statusCode int, duration time.Duration, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "method", method,
                "path", path,
                "status_code", statusCode,
                "duration_ms", duration.Milliseconds(),
        }
        args = append(args, keysAndValues...)
        l.Logger.Info("HTTP request", args...)
}</span>

func (l *Logger) LogGRPCRequest(method string, duration time.Duration, err error, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "grpc_method", method,
                "duration_ms", duration.Milliseconds(),
        }
        if err != nil </span><span class="cov0" title="0">{
                args = append(args, "error", err.Error())
        }</span>
        <span class="cov0" title="0">args = append(args, keysAndValues...)

        if err != nil </span><span class="cov0" title="0">{
                l.Logger.Error("gRPC request failed", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Info("gRPC request", args...)
        }</span>
}

// Database operation logging helpers

func (l *Logger) LogDatabaseQuery(query string, duration time.Duration, err error, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "query", query,
                "duration_ms", duration.Milliseconds(),
        }
        if err != nil </span><span class="cov0" title="0">{
                args = append(args, "error", err.Error())
        }</span>
        <span class="cov0" title="0">args = append(args, keysAndValues...)

        if err != nil </span><span class="cov0" title="0">{
                l.Logger.Error("Database query failed", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Debug("Database query", args...)
        }</span>
}

// Security event logging

func (l *Logger) LogSecurityEvent(event string, userID, organizationID string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "security_event", event,
                "user_id", userID,
                "organization_id", organizationID,
        }
        args = append(args, keysAndValues...)
        l.Logger.Warn("Security event", args...)
}</span>

func (l *Logger) LogAuthenticationAttempt(userID, organizationID string, success bool, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "authentication_attempt", true,
                "user_id", userID,
                "organization_id", organizationID,
                "success", success,
        }
        args = append(args, keysAndValues...)

        if success </span><span class="cov0" title="0">{
                l.Logger.Info("Authentication successful", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Warn("Authentication failed", args...)
        }</span>
}

func (l *Logger) LogAuthorizationAttempt(userID, organizationID, activityType string, success bool, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "authorization_attempt", true,
                "user_id", userID,
                "organization_id", organizationID,
                "activity_type", activityType,
                "success", success,
        }
        args = append(args, keysAndValues...)

        if success </span><span class="cov0" title="0">{
                l.Logger.Info("Authorization successful", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Warn("Authorization failed", args...)
        }</span>
}

// Activity logging

func (l *Logger) LogActivity(activityType, activityID, userID, organizationID string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "activity_type", activityType,
                "activity_id", activityID,
                "user_id", userID,
                "organization_id", organizationID,
        }
        args = append(args, keysAndValues...)
        l.Logger.Info("Activity executed", args...)
}</span>

// Service health logging

func (l *Logger) LogServiceHealth(serviceName, status string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        args := []interface{}{
                "service_name", serviceName,
                "health_status", status,
        }
        args = append(args, keysAndValues...)

        if status == "healthy" </span><span class="cov0" title="0">{
                l.Logger.Debug("Service health check", args...)
        }</span> else<span class="cov0" title="0"> {
                l.Logger.Error("Service unhealthy", args...)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
